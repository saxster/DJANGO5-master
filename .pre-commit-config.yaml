# Pre-commit hooks configuration
# See https://pre-commit.com for more information

repos:
  # Local validation hooks
  - repo: local
    hooks:
      # NOTE: AI Mentor hooks removed (apps.mentor moved to separate service - Nov 1, 2025)
      # Removed hooks: mentor-guard-validation, mentor-security-scan, mentor-quality-check, mentor-secret-scan

      # GITLEAKS SECRET SCANNER (Industry-standard)
      - id: gitleaks-protect
        name: Gitleaks Secret Scanner (Protect Mode)
        entry: gitleaks protect --verbose --redact --staged
        language: system
        pass_filenames: false
        stages: [commit]
        verbose: true

      # SETTINGS COMPLIANCE VALIDATION
      - id: settings-line-count-compliance
        name: Settings Line Count Compliance
        entry: python -c "
from intelliwiz_config.settings.validation import validate_line_count_compliance
import sys
result = validate_line_count_compliance()
if not result['compliant']:
    print('Settings line count violations found:')
    for violation in result['violations']:
        print(f'  {violation}')
    print('All settings modules must be under 200 lines (.claude/rules.md)')
    sys.exit(1)
print('âœ… All settings modules comply with 200-line limit')
"
        language: system
        files: 'intelliwiz_config/settings/.*\.py$'
        pass_filenames: false
        stages: [commit]

      # SECURITY FIX VALIDATION HOOKS
      # NOTE: Generic exception handling (E722) is now enforced by flake8
      # This hook only checks method line count limits
      - id: architecture-rules-validation
        name: Architecture Rules Validation (Method Line Count)
        entry: python -c "
import sys, re, os
violations = []
for filepath in sys.argv[1:]:
    if not filepath.endswith('.py'): continue
    try:
        with open(filepath, 'r') as f:
            content = f.read()
            lines = content.split('\n')
            # Check for oversized methods (>30 lines)
            in_method = False
            method_lines = 0
            for i, line in enumerate(lines):
                if re.match(r'\s*def \w+\(', line):
                    in_method = True
                    method_lines = 1
                    method_start = i
                elif in_method:
                    if line.strip() and not line.startswith(' '):
                        if method_lines > 30:
                            violations.append(f'{filepath}:{method_start+1}: Method exceeds 30 lines ({method_lines} lines)')
                        in_method = False
                    else:
                        method_lines += 1
            # NOTE: 'except Exception:' check removed - now handled by flake8 E722
if violations:
    print('Architecture violations found:')
    for v in violations: print(f'  {v}')
    sys.exit(1)
"
        language: system
        files: '^apps/.*\.py$'
        exclude: '(migrations|tests)'

      - id: logging-security-validation
        name: Logging Security Validation
        entry: python -c "
import sys, re
violations = []
for filepath in sys.argv[1:]:
    if not filepath.endswith('.py'): continue
    try:
        with open(filepath, 'r') as f:
            content = f.read()
            lines = content.split('\n')
            for i, line in enumerate(lines):
                # Check for email logging
                if re.search(r'logger\.(info|debug|error|warning).*\.email', line, re.IGNORECASE):
                    violations.append(f'{filepath}:{i+1}: Email address in log message')
                # Check for password logging
                if re.search(r'logger\.(info|debug|error|warning).*password', line, re.IGNORECASE):
                    violations.append(f'{filepath}:{i+1}: Password reference in log message')
                # Check for token logging
                if re.search(r'logger\.(info|debug|error|warning).*token', line, re.IGNORECASE):
                    violations.append(f'{filepath}:{i+1}: Token reference in log message')
if violations:
    print('Logging security violations found:')
    for v in violations: print(f'  {v}')
    sys.exit(1)
"
        language: system
        files: '^apps/.*\.py$'
        exclude: '(migrations|tests)'

      - id: query-optimization-validation
        name: Query Optimization Validation
        entry: python -c "
import sys, re
violations = []
for filepath in sys.argv[1:]:
    if not filepath.endswith('.py'): continue
    try:
        with open(filepath, 'r') as f:
            content = f.read()
            # Check for unoptimized queries
            unoptimized_patterns = [
                (r'\.objects\.all\(\)(?!\.(?:select_related|prefetch_related))', 'Unoptimized .objects.all()'),
                (r'\.objects\.filter\([^)]+\)(?!\.(?:select_related|prefetch_related))', 'Unoptimized .objects.filter()'),
                (r'for\s+\w+\s+in\s+.*?\.objects\.get\(', 'Potential N+1: .objects.get() in loop')
            ]
            lines = content.split('\n')
            for i, line in enumerate(lines):
                for pattern, message in unoptimized_patterns:
                    if re.search(pattern, line, re.MULTILINE):
                        violations.append(f'{filepath}:{i+1}: {message}')
if violations:
    print('Query optimization issues found:')
    for v in violations: print(f'  {v}')
    print('Consider using select_related() or prefetch_related() for better performance')
    sys.exit(1)
"
        language: system
        files: '^apps/.*\.py$'
        exclude: '(migrations|tests)'

      - id: secure-encryption-validation
        name: Secure Encryption Validation
        entry: python -c "
import sys, re
violations = []
for filepath in sys.argv[1:]:
    if not filepath.endswith('.py'): continue
    try:
        with open(filepath, 'r') as f:
            content = f.read()
            # Check for insecure encryption patterns
            if 'zlib.compress' in content and 'base64' in content:
                lines = content.split('\n')
                for i, line in enumerate(lines):
                    if 'zlib.compress' in line or ('base64' in line and 'zlib' in content):
                        violations.append(f'{filepath}:{i+1}: Insecure zlib compression detected - use SecureEncryptionService')
if violations:
    print('Insecure encryption patterns found:')
    for v in violations: print(f'  {v}')
    sys.exit(1)
"
        language: system
        files: '^apps/.*\.py$'
        exclude: '(migrations|tests)'

      # COMPREHENSIVE FILE SIZE LIMITS
      - id: file-size-validation
        name: File Size Limits (Architecture Rules)
        entry: python scripts/check_file_sizes.py --pre-commit
        language: system
        types: [python]
        pass_filenames: false
        stages: [commit]

      # CYCLOMATIC COMPLEXITY VALIDATION
      - id: cyclomatic-complexity-check
        name: Cyclomatic Complexity Check (max 10 per method)
        entry: python -c "
import sys, ast, re
violations = []
for filepath in sys.argv[1:]:
    if not filepath.endswith('.py') or 'migrations' in filepath or 'test_' in filepath: continue
    try:
        with open(filepath, 'r') as f:
            content = f.read()
        tree = ast.parse(content, filename=filepath)
        for node in ast.walk(tree):
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                # Simple complexity metric: count decision points
                complexity = 1  # Base complexity
                for child in ast.walk(node):
                    if isinstance(child, (ast.If, ast.While, ast.For, ast.AsyncFor,
                                         ast.ExceptHandler, ast.With, ast.AsyncWith,
                                         ast.BoolOp)):
                        complexity += 1
                if complexity > 10:
                    violations.append(f'{filepath}:{node.lineno}: Method {node.name} has complexity {complexity} (max: 10)')
    except Exception:
        pass
if violations:
    print('Cyclomatic complexity violations found:')
    for v in violations[:20]: print(f'  {v}')
    if len(violations) > 20: print(f'  ... and {len(violations)-20} more')
    print('Refactor complex methods into smaller, focused functions')
    sys.exit(1)
"
        language: system
        files: '^apps/.*\.py$'
        exclude: '(migrations|tests)'

      # NETWORK TIMEOUT VALIDATION
      - id: network-timeout-validation
        name: Network Timeout Validation (requests must have timeout)
        entry: python scripts/check_network_timeouts.py --pre-commit
        language: system
        types: [python]
        pass_filenames: false
        stages: [commit]

      # CIRCULAR DEPENDENCY DETECTION
      - id: circular-dependency-check
        name: Circular Dependency Detection
        entry: python scripts/check_circular_deps.py --pre-commit
        language: system
        types: [python]
        pass_filenames: false
        stages: [commit]

      # IMPORT ORGANIZATION VALIDATION HOOKS
      - id: import-validation
        name: Import Organization Validation
        entry: python3 standalone_import_analyzer.py
        language: system
        types: [python]
        pass_filenames: false
        stages: [commit]
        verbose: true

      - id: import-style-check
        name: Import Style Consistency Check
        entry: python3 fix_import_styles.py --dry-run
        language: system
        types: [python]
        pass_filenames: false
        stages: [commit]
        verbose: true

      - id: unused-imports-check
        name: Unused Imports Detection
        entry: python -c "
import sys, ast, os
violations = []
for filepath in sys.argv[1:]:
    if not filepath.endswith('.py') or 'migrations' in filepath: continue
    try:
        with open(filepath, 'r') as f:
            content = f.read()
        tree = ast.parse(content)
        imports = []
        used_names = set()
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    import_name = alias.asname if alias.asname else alias.name.split('.')[0]
                    imports.append((import_name, node.lineno, f'import {alias.name}'))
            elif isinstance(node, ast.ImportFrom) and node.module:
                for alias in node.names:
                    import_name = alias.asname if alias.asname else alias.name
                    imports.append((import_name, node.lineno, f'from {node.module} import {alias.name}'))
            elif isinstance(node, ast.Name) and isinstance(node.ctx, ast.Load):
                used_names.add(node.id)
            elif isinstance(node, ast.Attribute) and isinstance(node.value, ast.Name):
                used_names.add(node.value.id)
        for import_name, line_no, import_stmt in imports:
            if import_name not in used_names and import_name != '*':
                violations.append(f'{filepath}:{line_no}: Unused import - {import_stmt}')
    except Exception:
        pass
if violations:
    print('Unused imports found:')
    for v in violations[:10]: print(f'  {v}')
    if len(violations) > 10: print(f'  ... and {len(violations)-10} more')
    print('Run: python3 standalone_import_analyzer.py --fix-unused')
    sys.exit(1)
"
        language: system
        files: '^apps/.*\.py$'
        exclude: '(migrations|tests)'

  # Standard Python hooks
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.4.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-json
      - id: check-merge-conflict
      - id: check-added-large-files
        args: ['--maxkb=500']

  # Python formatting
  - repo: https://github.com/psf/black
    rev: 23.9.1
    hooks:
      - id: black
        language_version: python3

  # Python import sorting with Django support
  - repo: https://github.com/pycqa/isort
    rev: 5.12.0
    hooks:
      - id: isort
        args: ["--profile", "django", "--multi-line", "3", "--trailing-comma", "--force-grid-wrap", "0", "--combine-as", "--line-width", "88"]

  # Python linting
  - repo: https://github.com/pycqa/flake8
    rev: 6.1.0
    hooks:
      - id: flake8
        args: [--config=.flake8]
        additional_dependencies:
          - flake8-print  # T001: Detect print() statements in production code

  # Django specific checks
  - repo: local
    hooks:
      - id: django-check
        name: Django Check
        entry: python manage.py check
        language: system
        files: '\.py$'
        pass_filenames: false
        stages: [commit]

      - id: django-makemigrations-check
        name: Django Migrations Check
        entry: python manage.py makemigrations --check --dry-run
        language: system
        files: '\.py$'
        pass_filenames: false
        stages: [commit]

      # CELERY BEAT TASK VALIDATION
      - id: celery-beat-task-validation
        name: Celery Beat Task Validation (Orphaned Tasks Check)
        entry: python manage.py validate_schedules --check-orphaned-tasks --format json
        language: system
        files: '(intelliwiz_config/celery\.py|background_tasks/.*\.py|apps/.*/services/.*\.py)$'
        pass_filenames: false
        stages: [commit]
        verbose: true

  # Security scanning
  - repo: https://github.com/PyCQA/bandit
    rev: 1.7.5
    hooks:
      - id: bandit
        args: ['-r', '.', '--skip', 'B101,B601']

  # Secret scanning with detect-secrets
  - repo: https://github.com/Yelp/detect-secrets
    rev: v1.4.0
    hooks:
      - id: detect-secrets
        name: Detect Secrets Scanner
        args: ['--baseline', '.secrets.baseline']
        exclude: |
          (?x)^(
            \.secrets\.baseline|
            \.git/.*|
            \.pytest_cache/.*|
            __pycache__/.*|
            .*\.egg-info/.*|
            coverage_reports/.*|
            htmlcov/.*|
            \.archive/.*
          )$

  # Type checking (optional - uncomment if using mypy)
  # - repo: https://github.com/pre-commit/mirrors-mypy
  #   rev: v1.5.1
  #   hooks:
  #     - id: mypy
  #       additional_dependencies: [django-stubs]