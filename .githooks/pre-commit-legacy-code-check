#!/bin/bash
# Pre-commit hook to prevent legacy code anti-patterns
# Created: 2025-10-31
# Purpose: Enforce legacy code cleanup standards from comprehensive remediation

set -e

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

echo "üîç Running legacy code anti-pattern checks..."

# Get list of staged Python files (excluding migrations and tests)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.py$' | grep -v '/migrations/' | grep -v '/tests/' || true)

if [ -z "$STAGED_FILES" ]; then
    echo "‚úÖ No Python files to check"
    exit 0
fi

ERRORS=0

# Check 1: Broken function usage
echo "Checking for broken function imports..."
for file in $STAGED_FILES; do
    if grep -n "from.*string_utils.*format_data" "$file" 2>/dev/null; then
        echo -e "${RED}‚ùå ERROR: $file uses removed broken function 'format_data' from string_utils${NC}"
        echo "   Use the working version from apps.reports.utils instead"
        ERRORS=$((ERRORS + 1))
    fi
done

# Check 2: Missing exception imports
echo "Checking for missing exception imports..."
for file in $STAGED_FILES; do
    # Check if file uses DatabaseError or IntegrityError in except blocks
    if grep -E "except.*\(.*DatabaseError" "$file" >/dev/null 2>&1; then
        # Check if it imports them
        if ! grep -E "from django.db import.*DatabaseError" "$file" >/dev/null 2>&1; then
            echo -e "${RED}‚ùå ERROR: $file uses DatabaseError without importing it${NC}"
            echo "   Add: from django.db import DatabaseError, IntegrityError"
            ERRORS=$((ERRORS + 1))
        fi
    fi

    if grep -E "except.*\(.*ValidationError" "$file" >/dev/null 2>&1; then
        if ! grep -E "from django.core.exceptions import.*ValidationError" "$file" >/dev/null 2>&1; then
            echo -e "${RED}‚ùå ERROR: $file uses ValidationError without importing it${NC}"
            echo "   Add: from django.core.exceptions import ValidationError"
            ERRORS=$((ERRORS + 1))
        fi
    fi
done

# Check 3: Timezone-naive datetime usage
echo "Checking for timezone-naive datetime usage..."
for file in $STAGED_FILES; do
    # Skip archived/deprecated files
    if echo "$file" | grep -E "archive|deprecated|legacy" >/dev/null; then
        continue
    fi

    if grep -n "datetime\.datetime\.now()" "$file" 2>/dev/null; then
        echo -e "${RED}‚ùå ERROR: $file uses timezone-naive datetime.datetime.now()${NC}"
        echo "   Use timezone.now() from django.utils instead"
        echo "   Add: from django.utils import timezone"
        ERRORS=$((ERRORS + 1))
    fi
done

# Check 4: time.sleep() in request paths
echo "Checking for blocking time.sleep() in request paths..."
for file in $STAGED_FILES; do
    # Only check views and utils (request paths)
    if echo "$file" | grep -E "views\.py$|/utils\.py$" >/dev/null; then
        if grep -n "time\.sleep" "$file" 2>/dev/null; then
            # Check if it has a justification comment nearby
            if ! grep -B5 "time\.sleep" "$file" | grep -E "NOTE:|JUSTIFICATION:|acceptable" >/dev/null 2>&1; then
                echo -e "${YELLOW}‚ö†Ô∏è  WARNING: $file uses time.sleep() without justification${NC}"
                echo "   Consider using @with_retry decorator from apps.core.utils_new.retry_mechanism"
                echo "   Or add a comment explaining why time.sleep is necessary"
                # Don't block commit for warnings
            fi
        fi
    fi
done

# Check 5: Dangerous wildcard imports
echo "Checking for dangerous wildcard imports..."
for file in $STAGED_FILES; do
    # Skip __init__.py and admin.py where wildcard imports are acceptable Django patterns
    if echo "$file" | grep -E "__init__\.py$|admin\.py$|admin/__init__\.py$" >/dev/null; then
        continue
    fi

    if grep -n "from apps\.core\.utils import \*" "$file" 2>/dev/null; then
        echo -e "${RED}‚ùå ERROR: $file uses wildcard import from apps.core.utils${NC}"
        echo "   Use explicit imports instead"
        ERRORS=$((ERRORS + 1))
    fi

    if grep -n "from apps\.core\.utils_new import \*" "$file" 2>/dev/null; then
        echo -e "${RED}‚ùå ERROR: $file uses wildcard import from apps.core.utils_new${NC}"
        echo "   Use explicit imports instead"
        ERRORS=$((ERRORS + 1))
    fi
done

# Check 6: Usage of deprecated/removed functions
echo "Checking for deprecated function usage..."
for file in $STAGED_FILES; do
    # Check for encrypt/decrypt from string_utils (now removed from exports)
    if grep -E "from.*string_utils.*import.*(encrypt|decrypt)" "$file" 2>/dev/null | grep -v "SecureEncryptionService" | grep -v "#.*"; then
        echo -e "${RED}‚ùå ERROR: $file imports deprecated encrypt/decrypt from string_utils${NC}"
        echo "   Use apps.core.services.secure_encryption_service.SecureEncryptionService instead"
        ERRORS=$((ERRORS + 1))
    fi

    # Check for removed utility functions
    if grep -E "from.*utils.*import.*(display_post_data|printsql|get_select_output)" "$file" 2>/dev/null; then
        echo -e "${RED}‚ùå ERROR: $file imports removed utility function${NC}"
        echo "   These functions have been removed from exports"
        ERRORS=$((ERRORS + 1))
    fi
done

# Summary
echo ""
if [ $ERRORS -gt 0 ]; then
    echo -e "${RED}‚ùå Pre-commit check FAILED with $ERRORS error(s)${NC}"
    echo ""
    echo "Fix the errors above and try again."
    echo "See .claude/rules.md for code standards."
    exit 1
else
    echo -e "${GREEN}‚úÖ All legacy code checks passed!${NC}"
    exit 0
fi
