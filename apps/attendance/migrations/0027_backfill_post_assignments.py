# Generated by Claude Code on 2025-11-03
# Phase 2: Data Migration - Backfill PostAssignments from Jobneed

from django.db import migrations
from datetime import datetime, timedelta


def backfill_post_assignments_from_jobneed(apps, schema_editor):
    """
    Backfill PostAssignment records from Jobneed records.

    Creates explicit roster entries from implicit job assignments.

    Logic:
    1. Find all Jobneed records with performedby, shift, bu, and plandatetime
    2. For each Jobneed, find matching Post (by site + shift)
    3. Create PostAssignment linking worker to post
    4. Set status based on Jobneed.jobstatus
    5. Link to PeopleEventlog if check-in record exists

    Handles:
    - Multiple Jobneeds per day (different posts)
    - Historical data (last 90 days)
    - Missing post matches (creates generic post)
    - Duplicate prevention
    """
    Jobneed = apps.get_model('activity', 'Jobneed')
    Post = apps.get_model('attendance', 'Post')
    PostAssignment = apps.get_model('attendance', 'PostAssignment')
    PeopleEventlog = apps.get_model('attendance', 'PeopleEventlog')

    assignments_created = 0
    skipped_count = 0
    errors = []

    try:
        # Only backfill last 90 days to avoid performance issues
        from django.utils import timezone
        cutoff_date = timezone.now().date() - timedelta(days=90)

        # Get Jobneeds with required fields
        jobneeds = Jobneed.objects.filter(
            performedby__isnull=False,
            bu__isnull=False,
            shift__isnull=False,
            plandatetime__date__gte=cutoff_date
        ).select_related('performedby', 'bu', 'shift').order_by('plandatetime')

        print(f"Found {jobneeds.count()} Jobneed records to process (last 90 days)")

        for jobneed in jobneeds:
            try:
                # Extract date and time from plandatetime
                assignment_date = jobneed.plandatetime.date()
                start_time = jobneed.shift.starttime
                end_time = jobneed.shift.endtime

                # Find matching post (by site + shift)
                # Preference: Find post linked to this jobneed's zone/location
                posts = Post.objects.filter(
                    site=jobneed.bu,
                    shift=jobneed.shift,
                    active=True,
                    tenant=jobneed.bu.tenant
                )

                if not posts.exists():
                    # No matching post found - create a generic post for this shift
                    post_code = f"{jobneed.bu.bucode[:8]}-{jobneed.shift.shiftname[:8].upper().replace(' ', '')}"
                    post_name = f"General Duty - {jobneed.shift.shiftname}"

                    post = Post.objects.create(
                        post_code=post_code,
                        post_name=post_name,
                        post_type='OTHER',
                        site=jobneed.bu,
                        shift=jobneed.shift,
                        gps_coordinates=jobneed.bu.gpslocation if hasattr(jobneed.bu, 'gpslocation') else None,
                        geofence_radius=100,
                        required_guard_count=1,
                        armed_required=False,
                        post_orders=f"General duty post for {jobneed.shift.shiftname}",
                        post_orders_version=1,
                        risk_level='MEDIUM',
                        active=True,
                        coverage_required=True,
                        temporary=False,
                        post_metadata={
                            'created_from': 'jobneed_backfill',
                            'migration_date': '2025-11-03',
                            'is_generic': True,
                        },
                        tenant=jobneed.bu.tenant,
                        client=jobneed.bu,
                    )
                    print(f"Created generic post: {post_code}")
                else:
                    # Use first matching post (or we could use smart matching logic)
                    post = posts.first()

                # Map Jobneed.jobstatus to PostAssignment.status
                status_mapping = {
                    'ASSIGNED': 'SCHEDULED',
                    'INPROGRESS': 'IN_PROGRESS',
                    'COMPLETED': 'COMPLETED',
                    'CANCELLED': 'CANCELLED',
                    'PENDING': 'SCHEDULED',
                }
                assignment_status = status_mapping.get(jobneed.jobstatus, 'SCHEDULED')

                # Check if assignment already exists
                existing_assignment = PostAssignment.objects.filter(
                    worker=jobneed.performedby,
                    post=post,
                    assignment_date=assignment_date,
                    shift=jobneed.shift,
                    tenant=jobneed.bu.tenant
                ).first()

                if existing_assignment:
                    skipped_count += 1
                    continue

                # Find linked attendance record if exists
                attendance_record = PeopleEventlog.objects.filter(
                    people=jobneed.performedby,
                    bu=jobneed.bu,
                    shift=jobneed.shift,
                    datefor=assignment_date
                ).first()

                # Create PostAssignment
                assignment = PostAssignment.objects.create(
                    worker=jobneed.performedby,
                    post=post,
                    shift=jobneed.shift,
                    site=jobneed.bu,
                    assignment_date=assignment_date,
                    start_time=start_time,
                    end_time=end_time,
                    status=assignment_status,
                    attendance_record=attendance_record,
                    is_override=False,
                    assignment_metadata={
                        'migrated_from_jobneed_id': jobneed.id,
                        'migration_date': '2025-11-03',
                        'original_jobstatus': jobneed.jobstatus,
                    },
                    tenant=jobneed.bu.tenant,
                    client=jobneed.bu,
                )

                # Update timestamps based on attendance record
                if attendance_record:
                    if attendance_record.punchintime:
                        assignment.checked_in_at = attendance_record.punchintime
                        assignment.status = 'IN_PROGRESS'
                    if attendance_record.punchouttime:
                        assignment.checked_out_at = attendance_record.punchouttime
                        assignment.status = 'COMPLETED'

                        # Calculate hours worked
                        if attendance_record.punchintime and attendance_record.punchouttime:
                            duration = attendance_record.punchouttime - attendance_record.punchintime
                            assignment.hours_worked = round(duration.total_seconds() / 3600, 2)

                    assignment.save()

                    # Link attendance record back to assignment
                    attendance_record.post_assignment = assignment
                    attendance_record.post = post
                    attendance_record.save(update_fields=['post_assignment', 'post'])

                assignments_created += 1

                if assignments_created % 100 == 0:
                    print(f"Progress: {assignments_created} assignments created...")

            except Exception as e:
                error_msg = f"Error processing Jobneed {jobneed.id}: {str(e)}"
                errors.append(error_msg)
                continue

        print(f"\nBackfill complete:")
        print(f"  - {assignments_created} post assignments created")
        print(f"  - {skipped_count} duplicates skipped")
        if errors:
            print(f"  - {len(errors)} errors encountered")
            for error in errors[:10]:
                print(f"    {error}")

    except Exception as e:
        print(f"Critical error during backfill: {str(e)}")
        raise


def reverse_backfill(apps, schema_editor):
    """
    Reverse migration - delete post assignments created from jobneed

    Only deletes assignments with migration_source='jobneed_backfill' in metadata
    """
    PostAssignment = apps.get_model('attendance', 'PostAssignment')
    PeopleEventlog = apps.get_model('attendance', 'PeopleEventlog')

    # Clear post links from attendance records
    PeopleEventlog.objects.filter(
        post_assignment__assignment_metadata__migrated_from_jobneed_id__isnull=False
    ).update(post=None, post_assignment=None)

    # Delete backfilled assignments
    deleted_count = PostAssignment.objects.filter(
        assignment_metadata__migrated_from_jobneed_id__isnull=False
    ).delete()[0]

    print(f"Deleted {deleted_count} backfilled post assignments")


class Migration(migrations.Migration):

    dependencies = [
        ('attendance', '0026_backfill_posts_from_zones'),
        ('activity', '0001_initial'),  # Adjust to actual latest
    ]

    operations = [
        migrations.RunPython(
            backfill_post_assignments_from_jobneed,
            reverse_code=reverse_backfill,
        ),
    ]
