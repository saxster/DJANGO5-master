"""
Unit tests for face recognition models
Tests all face recognition model functionality and relationships
"""

from django.test import TestCase
from django.core.exceptions import ValidationError
from django.db import IntegrityError
from django.utils import timezone
from datetime import datetime, timedelta
import json

from apps.face_recognition.models import (
    FaceRecognitionModel, FaceEmbedding, FaceVerificationLog,
    AntiSpoofingModel, FaceQualityMetrics, FaceRecognitionConfig
)
from tests.factories import (
    FaceRecognitionModelFactory, FaceEmbeddingFactory, FaceVerificationLogFactory,
    AntiSpoofingModelFactory, FaceRecognitionConfigFactory, UserFactory
)
from tests.utils import AITestCase


class FaceRecognitionModelTest(AITestCase):
    """Test FaceRecognitionModel functionality"""
    
    def test_create_face_recognition_model(self):
        """Test basic face recognition model creation"""
        model = FaceRecognitionModel.objects.create(
            name='FaceNet512 Production',
            model_type='FACENET512',
            version='1.0',
            status='ACTIVE',
            similarity_threshold=0.3,
            confidence_threshold=0.7,
            accuracy=0.95,
            processing_time_ms=150.0
        )
        
        self.assertEqual(model.name, 'FaceNet512 Production')
        self.assertEqual(model.model_type, 'FACENET512')
        self.assertEqual(model.status, 'ACTIVE')
        self.assertEqual(model.similarity_threshold, 0.3)
    
    def test_model_type_choices(self):
        """Test valid model type choices"""
        valid_types = ['FACENET512', 'ARCFACE', 'INSIGHTFACE', 'ENSEMBLE', 'CUSTOM']
        
        for model_type in valid_types:
            model = FaceRecognitionModelFactory(model_type=model_type)
            self.assertEqual(model.model_type, model_type)
    
    def test_status_choices(self):
        """Test valid status choices"""
        valid_statuses = ['ACTIVE', 'INACTIVE', 'TRAINING', 'DEPRECATED']
        
        for status in valid_statuses:
            model = FaceRecognitionModelFactory(status=status)
            self.assertEqual(model.status, status)
    
    def test_hyperparameters_json_field(self):
        """Test hyperparameters JSON field functionality"""
        complex_hyperparameters = {
            'model_architecture': {
                'input_size': [160, 160, 3],
                'embedding_size': 512,
                'num_layers': 50,
                'activation': 'relu'
            },
            'training_parameters': {
                'learning_rate': 0.001,
                'batch_size': 32,
                'epochs': 100,
                'optimizer': 'adam',
                'loss_function': 'triplet_loss',
                'margin': 0.5
            },
            'preprocessing': {
                'normalization': 'mean_std',
                'augmentation': {
                    'rotation_range': 10,
                    'width_shift_range': 0.1,
                    'height_shift_range': 0.1,
                    'horizontal_flip': True
                }
            }
        }
        
        model = FaceRecognitionModelFactory(hyperparameters=complex_hyperparameters)
        model.refresh_from_db()
        
        self.assertEqual(model.hyperparameters, complex_hyperparameters)
        self.assertEqual(
            model.hyperparameters['model_architecture']['embedding_size'], 512
        )
        self.assertEqual(
            model.hyperparameters['training_parameters']['optimizer'], 'adam'
        )
    
    def test_performance_metrics_tracking(self):
        """Test performance metrics storage and calculation"""
        model = FaceRecognitionModelFactory()
        
        # Update performance metrics
        model.accuracy = 0.967
        model.precision = 0.954
        model.recall = 0.941
        model.f1_score = 0.947
        model.processing_time_ms = 145.3
        model.save()
        
        model.refresh_from_db()
        self.assertEqual(model.accuracy, 0.967)
        self.assertEqual(model.f1_score, 0.947)
        self.assertEqual(model.processing_time_ms, 145.3)
    
    def test_liveness_detection_settings(self):
        """Test liveness detection configuration"""
        model = FaceRecognitionModelFactory(
            liveness_detection_enabled=True,
            liveness_threshold=0.75,
            anti_spoofing_enabled=True,
            spoof_detection_threshold=0.8
        )
        
        self.assertTrue(model.liveness_detection_enabled)
        self.assertEqual(model.liveness_threshold, 0.75)
        self.assertTrue(model.anti_spoofing_enabled)
        self.assertEqual(model.spoof_detection_threshold, 0.8)
    
    def test_model_versioning(self):
        """Test model versioning system"""
        # Create different versions of same model type
        v1_model = FaceRecognitionModelFactory(
            name='FaceNet Model v1.0',
            model_type='FACENET512',
            version='1.0'
        )
        v2_model = FaceRecognitionModelFactory(
            name='FaceNet Model v2.0',
            model_type='FACENET512',
            version='2.0'
        )
        
        self.assertEqual(v1_model.version, '1.0')
        self.assertEqual(v2_model.version, '2.0')
        
        # Can have multiple versions
        facenet_models = FaceRecognitionModel.objects.filter(model_type='FACENET512')
        self.assertEqual(facenet_models.count(), 2)
    
    def test_training_metadata(self):
        """Test training metadata storage"""
        training_metadata = {
            'training_dataset': {
                'name': 'VGGFace2',
                'size': 3300000,
                'num_identities': 9131,
                'preprocessing': 'mtcnn_aligned'
            },
            'training_history': {
                'start_time': '2023-12-01T10:00:00Z',
                'end_time': '2023-12-03T14:30:00Z',
                'total_epochs': 150,
                'best_epoch': 142,
                'best_validation_accuracy': 0.967
            },
            'hardware_used': {
                'gpus': ['Tesla V100', 'Tesla V100'],
                'memory_gb': 64,
                'training_time_hours': 52.5
            }
        }
        
        model = FaceRecognitionModelFactory(training_metadata=training_metadata)
        model.refresh_from_db()
        
        self.assertEqual(model.training_metadata, training_metadata)
        self.assertEqual(
            model.training_metadata['training_dataset']['num_identities'], 9131
        )
    
    def test_unique_name_constraint(self):
        """Test unique name constraint"""
        model1 = FaceRecognitionModelFactory(name='Unique Model Name')
        
        with self.assertRaises(IntegrityError):
            FaceRecognitionModelFactory(name='Unique Model Name')
    
    def test_str_representation(self):
        """Test string representation"""
        model = FaceRecognitionModelFactory(
            name='Test Model',
            model_type='FACENET512',
            version='1.0'
        )
        
        str_repr = str(model)
        self.assertIn('Test Model', str_repr)
        self.assertIn('FACENET512', str_repr)


class FaceEmbeddingTest(AITestCase):
    """Test FaceEmbedding functionality"""
    
    def setUp(self):
        super().setUp()
        self.user = UserFactory()
        self.model = FaceRecognitionModelFactory()
    
    def test_create_face_embedding(self):
        """Test basic face embedding creation"""
        embedding_vector = [0.1] * 512  # 512-dimensional vector
        
        embedding = FaceEmbedding.objects.create(
            user=self.user,
            extraction_model=self.model,
            embedding_vector=embedding_vector,
            face_confidence=0.92,
            is_validated=True,
            is_primary=True
        )
        
        self.assertEqual(embedding.user, self.user)
        self.assertEqual(embedding.extraction_model, self.model)
        self.assertEqual(len(embedding.embedding_vector), 512)
        self.assertEqual(embedding.face_confidence, 0.92)
        self.assertTrue(embedding.is_validated)
    
    def test_embedding_vector_dimensions(self):
        """Test embedding vector dimension validation"""
        # Valid 512-dimensional vector
        valid_embedding = FaceEmbeddingFactory(
            user=self.user,
            embedding_vector=[0.1] * 512
        )
        self.assertEqual(len(valid_embedding.embedding_vector), 512)
        
        # Different dimension vectors should also be allowed
        # (some models might use different dimensions)
        different_dim_embedding = FaceEmbedding.objects.create(
            user=self.user,
            extraction_model=self.model,
            embedding_vector=[0.1] * 256,  # 256 dimensions
            face_confidence=0.85
        )
        self.assertEqual(len(different_dim_embedding.embedding_vector), 256)
    
    def test_image_metadata_storage(self):
        """Test image metadata JSON field"""
        metadata = {
            'original_image': {
                'width': 1920,
                'height': 1080,
                'format': 'JPEG',
                'file_size_bytes': 245760
            },
            'face_detection': {
                'bounding_box': [450, 200, 650, 450],
                'confidence': 0.98,
                'landmarks': {
                    'left_eye': [520, 280],
                    'right_eye': [580, 275],
                    'nose_tip': [550, 320],
                    'mouth_left': [530, 370],
                    'mouth_right': [570, 368]
                }
            },
            'preprocessing': {
                'aligned': True,
                'normalized': True,
                'resize_method': 'lanczos',
                'final_size': [160, 160]
            },
            'quality_assessment': {
                'sharpness': 0.89,
                'brightness': 0.76,
                'contrast': 0.82,
                'overall_quality': 0.85
            }
        }
        
        embedding = FaceEmbeddingFactory(
            user=self.user,
            image_metadata=metadata
        )
        
        embedding.refresh_from_db()
        self.assertEqual(embedding.image_metadata, metadata)
        self.assertEqual(
            embedding.image_metadata['face_detection']['confidence'], 0.98
        )
    
    def test_primary_embedding_constraint(self):
        """Test primary embedding uniqueness per user per model"""
        # Create primary embedding
        primary1 = FaceEmbeddingFactory(
            user=self.user,
            extraction_model=self.model,
            is_primary=True
        )
        
        # Create another embedding for same user/model
        # Only one should be primary at a time
        embedding2 = FaceEmbeddingFactory(
            user=self.user,
            extraction_model=self.model,
            is_primary=False
        )
        
        # Verify only one primary embedding per user per model
        primary_embeddings = FaceEmbedding.objects.filter(
            user=self.user,
            extraction_model=self.model,
            is_primary=True
        )
        self.assertEqual(primary_embeddings.count(), 1)
    
    def test_embedding_validation_status(self):
        """Test embedding validation workflow"""
        embedding = FaceEmbeddingFactory(
            user=self.user,
            is_validated=False,
            validation_method=None
        )
        
        # Initially not validated
        self.assertFalse(embedding.is_validated)
        self.assertIsNone(embedding.validation_method)
        
        # Validate embedding
        embedding.is_validated = True
        embedding.validation_method = 'manual_review'
        embedding.validated_by = UserFactory()
        embedding.validated_at = timezone.now()
        embedding.save()
        
        embedding.refresh_from_db()
        self.assertTrue(embedding.is_validated)
        self.assertEqual(embedding.validation_method, 'manual_review')
        self.assertIsNotNone(embedding.validated_by)
    
    def test_usage_statistics_tracking(self):
        """Test usage statistics for embeddings"""
        embedding = FaceEmbeddingFactory(
            user=self.user,
            verification_count=0,
            successful_matches=0
        )
        
        # Simulate usage
        embedding.verification_count = 25
        embedding.successful_matches = 23
        embedding.last_used = timezone.now()
        embedding.save()
        
        embedding.refresh_from_db()
        self.assertEqual(embedding.verification_count, 25)
        self.assertEqual(embedding.successful_matches, 23)
        
        # Calculate success rate
        success_rate = embedding.successful_matches / embedding.verification_count
        self.assertAlmostEqual(success_rate, 0.92, places=2)


class FaceVerificationLogTest(AITestCase):
    """Test FaceVerificationLog functionality"""
    
    def setUp(self):
        super().setUp()
        self.user = UserFactory()
        self.model = FaceRecognitionModelFactory()
        self.embedding = FaceEmbeddingFactory(user=self.user, extraction_model=self.model)
    
    def test_create_verification_log(self):
        """Test basic verification log creation"""
        log = FaceVerificationLog.objects.create(
            user=self.user,
            verification_model=self.model,
            matched_embedding=self.embedding,
            similarity_score=0.85,
            confidence_score=0.92,
            result='SUCCESS',
            processing_time_ms=145.3
        )
        
        self.assertEqual(log.user, self.user)
        self.assertEqual(log.verification_model, self.model)
        self.assertEqual(log.matched_embedding, self.embedding)
        self.assertEqual(log.result, 'SUCCESS')
    
    def test_result_choices(self):
        """Test valid result choices"""
        valid_results = ['SUCCESS', 'FAILED', 'INSUFFICIENT_QUALITY', 'NO_FACE_DETECTED', 'SPOOF_DETECTED']
        
        for result in valid_results:
            log = FaceVerificationLogFactory(
                user=self.user,
                result=result
            )
            self.assertEqual(log.result, result)
    
    def test_verification_details_storage(self):
        """Test verification details JSON field"""
        details = {
            'input_analysis': {
                'face_detected': True,
                'face_count': 1,
                'face_size': [120, 120],
                'face_quality_score': 0.87,
                'preprocessing_applied': ['alignment', 'normalization']
            },
            'similarity_analysis': {
                'distance_metric': 'cosine',
                'raw_distance': 0.23,
                'normalized_similarity': 0.85,
                'threshold_used': 0.3,
                'margin_above_threshold': 0.55
            },
            'ensemble_results': {
                'facenet512_score': 0.87,
                'arcface_score': 0.83,
                'insightface_score': 0.85,
                'ensemble_method': 'weighted_average',
                'final_score': 0.85
            },
            'performance_metrics': {
                'face_detection_time_ms': 15.2,
                'embedding_extraction_time_ms': 89.7,
                'similarity_calculation_time_ms': 2.8,
                'total_processing_time_ms': 145.3
            }
        }
        
        log = FaceVerificationLogFactory(
            user=self.user,
            verification_details=details
        )
        
        log.refresh_from_db()
        self.assertEqual(log.verification_details, details)
        self.assertEqual(
            log.verification_details['similarity_analysis']['distance_metric'],
            'cosine'
        )
    
    def test_anti_spoofing_results(self):
        """Test anti-spoofing detection results"""
        log = FaceVerificationLogFactory(
            user=self.user,
            spoof_detected=True,
            liveness_score=0.25,
            anti_spoofing_details={
                'texture_analysis': {
                    'score': 0.3,
                    'verdict': 'suspicious',
                    'features': ['low_texture_variation', 'uniform_lighting']
                },
                'motion_analysis': {
                    'score': 0.2,
                    'verdict': 'likely_spoof',
                    'features': ['no_natural_micro_movements', 'static_landmarks']
                },
                'depth_analysis': {
                    'score': 0.1,
                    'verdict': 'flat_surface_detected',
                    'features': ['no_depth_variation', 'uniform_distance']
                }
            }
        )
        
        self.assertTrue(log.spoof_detected)
        self.assertEqual(log.liveness_score, 0.25)
        self.assertIn('texture_analysis', log.anti_spoofing_details)
    
    def test_fraud_risk_assessment(self):
        """Test fraud risk assessment integration"""
        log = FaceVerificationLogFactory(
            user=self.user,
            fraud_risk_score=0.35,
            fraud_indicators=['low_confidence', 'unusual_location'],
            risk_assessment_details={
                'behavioral_factors': {
                    'time_consistency': 0.8,
                    'location_consistency': 0.6,
                    'device_consistency': 0.9
                },
                'biometric_factors': {
                    'face_quality': 0.85,
                    'liveness_confidence': 0.9,
                    'similarity_confidence': 0.82
                },
                'contextual_factors': {
                    'unusual_time': False,
                    'unusual_location': True,
                    'new_device': False
                }
            }
        )
        
        self.assertEqual(log.fraud_risk_score, 0.35)
        self.assertIn('unusual_location', log.fraud_indicators)
        self.assertIn('behavioral_factors', log.risk_assessment_details)
    
    def test_verification_timestamp_auto_set(self):
        """Test automatic timestamp setting"""
        before_creation = timezone.now()
        log = FaceVerificationLogFactory(user=self.user)
        after_creation = timezone.now()
        
        self.assertGreaterEqual(log.verification_timestamp, before_creation)
        self.assertLessEqual(log.verification_timestamp, after_creation)


class AntiSpoofingModelTest(AITestCase):
    """Test AntiSpoofingModel functionality"""
    
    def test_create_anti_spoofing_model(self):
        """Test basic anti-spoofing model creation"""
        model = AntiSpoofingModel.objects.create(
            name='Texture-based Spoof Detection',
            model_type='TEXTURE_BASED',
            version='1.0',
            liveness_threshold=0.5,
            accuracy=0.92,
            true_positive_rate=0.94,
            false_positive_rate=0.06
        )
        
        self.assertEqual(model.name, 'Texture-based Spoof Detection')
        self.assertEqual(model.model_type, 'TEXTURE_BASED')
        self.assertEqual(model.liveness_threshold, 0.5)
        self.assertEqual(model.accuracy, 0.92)
    
    def test_model_type_choices(self):
        """Test valid anti-spoofing model types"""
        valid_types = ['TEXTURE_BASED', 'MOTION_BASED', 'DEPTH_BASED', 'MULTI_MODAL', 'CHALLENGE_RESPONSE']
        
        for model_type in valid_types:
            model = AntiSpoofingModelFactory(model_type=model_type)
            self.assertEqual(model.model_type, model_type)
    
    def test_performance_metrics(self):
        """Test anti-spoofing performance metrics"""
        model = AntiSpoofingModelFactory(
            accuracy=0.95,
            true_positive_rate=0.96,  # Correctly detecting live faces
            false_positive_rate=0.04,  # Incorrectly flagging live faces as spoofs
            true_negative_rate=0.94,  # Correctly detecting spoofs
            false_negative_rate=0.02   # Incorrectly allowing spoofs
        )
        
        # Test metric relationships
        self.assertAlmostEqual(
            model.true_positive_rate + model.false_negative_rate,
            1.0, places=2
        )
        self.assertAlmostEqual(
            model.true_negative_rate + model.false_positive_rate,
            0.98, places=2  # Allowing for rounding
        )
    
    def test_requirements_flags(self):
        """Test interaction requirements"""
        interactive_model = AntiSpoofingModelFactory(
            model_type='CHALLENGE_RESPONSE',
            requires_motion=True,
            requires_user_interaction=True,
            requires_multiple_frames=True
        )
        
        self.assertTrue(interactive_model.requires_motion)
        self.assertTrue(interactive_model.requires_user_interaction)
        self.assertTrue(interactive_model.requires_multiple_frames)
        
        passive_model = AntiSpoofingModelFactory(
            model_type='TEXTURE_BASED',
            requires_motion=False,
            requires_user_interaction=False,
            requires_multiple_frames=False
        )
        
        self.assertFalse(passive_model.requires_motion)
        self.assertFalse(passive_model.requires_user_interaction)


class FaceQualityMetricsTest(AITestCase):
    """Test FaceQualityMetrics functionality"""
    
    def setUp(self):
        super().setUp()
        self.user = UserFactory()
        self.embedding = FaceEmbeddingFactory(user=self.user)
    
    def test_create_quality_metrics(self):
        """Test basic quality metrics creation"""
        metrics = FaceQualityMetrics.objects.create(
            face_embedding=self.embedding,
            overall_quality=0.85,
            sharpness_score=0.90,
            brightness_score=0.80,
            contrast_score=0.85,
            face_size_score=0.88,
            pose_quality=0.82
        )
        
        self.assertEqual(metrics.face_embedding, self.embedding)
        self.assertEqual(metrics.overall_quality, 0.85)
        self.assertEqual(metrics.sharpness_score, 0.90)
    
    def test_quality_issues_tracking(self):
        """Test quality issues array field"""
        quality_issues = [
            'LOW_SHARPNESS',
            'POOR_LIGHTING',
            'EXTREME_POSE',
            'PARTIAL_OCCLUSION'
        ]
        
        metrics = FaceQualityMetrics.objects.create(
            face_embedding=self.embedding,
            overall_quality=0.45,  # Low due to issues
            quality_issues=quality_issues
        )
        
        metrics.refresh_from_db()
        self.assertEqual(len(metrics.quality_issues), 4)
        self.assertIn('LOW_SHARPNESS', metrics.quality_issues)
        self.assertIn('PARTIAL_OCCLUSION', metrics.quality_issues)
    
    def test_improvement_suggestions(self):
        """Test improvement suggestions generation"""
        suggestions = [
            "Ensure camera is in focus and stable",
            "Improve lighting conditions",
            "Face camera directly",
            "Remove obstructions from face"
        ]
        
        metrics = FaceQualityMetrics.objects.create(
            face_embedding=self.embedding,
            overall_quality=0.60,
            quality_issues=['LOW_SHARPNESS', 'POOR_LIGHTING'],
            improvement_suggestions=suggestions
        )
        
        self.assertEqual(len(metrics.improvement_suggestions), 4)
        self.assertIn("Improve lighting conditions", metrics.improvement_suggestions)
    
    def test_detailed_analysis_storage(self):
        """Test detailed quality analysis JSON field"""
        detailed_analysis = {
            'face_detection': {
                'confidence': 0.98,
                'bounding_box_area': 14400,  # pixels
                'face_area_ratio': 0.15,  # % of image
                'face_position': 'centered'
            },
            'pose_analysis': {
                'yaw_angle': 5.2,
                'pitch_angle': -2.1,
                'roll_angle': 1.8,
                'frontal_score': 0.92,
                'pose_category': 'near_frontal'
            },
            'illumination_analysis': {
                'brightness_mean': 128.5,
                'brightness_std': 32.1,
                'contrast_ratio': 2.3,
                'shadow_detection': 'minimal',
                'lighting_uniformity': 0.85
            },
            'image_quality': {
                'resolution': [640, 480],
                'compression_artifacts': 'none',
                'noise_level': 0.15,
                'motion_blur': 0.08,
                'focus_measure': 0.92
            }
        }
        
        metrics = FaceQualityMetrics.objects.create(
            face_embedding=self.embedding,
            overall_quality=0.88,
            detailed_analysis=detailed_analysis
        )
        
        metrics.refresh_from_db()
        self.assertEqual(metrics.detailed_analysis, detailed_analysis)
        self.assertEqual(
            metrics.detailed_analysis['pose_analysis']['frontal_score'],
            0.92
        )
    
    def test_quality_score_relationships(self):
        """Test relationships between different quality scores"""
        # High quality scores should correlate with high overall quality
        high_quality_metrics = FaceQualityMetrics.objects.create(
            face_embedding=self.embedding,
            overall_quality=0.92,
            sharpness_score=0.95,
            brightness_score=0.88,
            contrast_score=0.90,
            face_size_score=0.94,
            pose_quality=0.91
        )
        
        # Calculate expected overall quality (weighted average)
        component_scores = [
            high_quality_metrics.sharpness_score,
            high_quality_metrics.brightness_score,
            high_quality_metrics.contrast_score,
            high_quality_metrics.face_size_score,
            high_quality_metrics.pose_quality
        ]
        
        expected_overall = sum(component_scores) / len(component_scores)
        
        # Overall quality should be close to component average
        self.assertAlmostEqual(
            high_quality_metrics.overall_quality,
            expected_overall,
            delta=0.05
        )


class FaceRecognitionConfigTest(AITestCase):
    """Test FaceRecognitionConfig functionality"""
    
    def test_create_face_recognition_config(self):
        """Test basic configuration creation"""
        config = FaceRecognitionConfig.objects.create(
            name='Production Face Recognition Settings',
            config_type='SYSTEM',
            description='Main system configuration for face recognition',
            config_data={
                'similarity_threshold': 0.3,
                'confidence_threshold': 0.7,
                'enable_anti_spoofing': True,
                'enable_ensemble': True
            },
            priority=10
        )
        
        self.assertEqual(config.name, 'Production Face Recognition Settings')
        self.assertEqual(config.config_type, 'SYSTEM')
        self.assertTrue(config.is_active)
        self.assertEqual(config.priority, 10)
    
    def test_config_type_choices(self):
        """Test valid configuration types"""
        valid_types = ['SYSTEM', 'SECURITY', 'PERFORMANCE', 'QUALITY', 'ENSEMBLE']
        
        for config_type in valid_types:
            config = FaceRecognitionConfigFactory(config_type=config_type)
            self.assertEqual(config.config_type, config_type)
    
    def test_complex_configuration_data(self):
        """Test complex configuration data structure"""
        complex_config = {
            'face_detection': {
                'detector_type': 'mtcnn',
                'min_face_size': 80,
                'detection_threshold': 0.8,
                'nms_threshold': 0.3
            },
            'face_recognition': {
                'models': {
                    'primary': 'facenet512',
                    'secondary': 'arcface',
                    'ensemble_weights': [0.6, 0.4]
                },
                'thresholds': {
                    'similarity': 0.3,
                    'confidence': 0.7,
                    'quality': 0.5
                }
            },
            'anti_spoofing': {
                'enabled': True,
                'models': ['texture_based', 'motion_based'],
                'threshold': 0.5,
                'challenge_response': {
                    'enabled': False,
                    'challenges': ['blink', 'smile', 'turn_head']
                }
            },
            'performance': {
                'max_processing_time_ms': 5000,
                'parallel_processing': True,
                'gpu_acceleration': True,
                'batch_size': 8
            }
        }
        
        config = FaceRecognitionConfigFactory(config_data=complex_config)
        config.refresh_from_db()
        
        self.assertEqual(config.config_data, complex_config)
        self.assertTrue(config.config_data['anti_spoofing']['enabled'])
        self.assertEqual(
            config.config_data['face_recognition']['models']['primary'],
            'facenet512'
        )
    
    def test_configuration_priority_ordering(self):
        """Test configuration priority system"""
        high_priority = FaceRecognitionConfigFactory(priority=1)
        medium_priority = FaceRecognitionConfigFactory(priority=10)
        low_priority = FaceRecognitionConfigFactory(priority=20)
        
        # Test ordering by priority
        configs = FaceRecognitionConfig.objects.order_by('priority')
        priorities = [config.priority for config in configs]
        
        self.assertEqual(priorities[0], 1)   # high_priority
        self.assertIn(10, priorities)        # medium_priority
        self.assertIn(20, priorities)        # low_priority
    
    def test_active_configurations_filtering(self):
        """Test filtering for active configurations"""
        active_config = FaceRecognitionConfigFactory(is_active=True)
        inactive_config = FaceRecognitionConfigFactory(is_active=False)
        
        active_configs = FaceRecognitionConfig.objects.filter(is_active=True)
        
        self.assertIn(active_config, active_configs)
        self.assertNotIn(inactive_config, active_configs)
    
    def test_config_versioning(self):
        """Test configuration versioning"""
        v1_config = FaceRecognitionConfigFactory(
            name='Face Recognition Settings',
            version='1.0'
        )
        v2_config = FaceRecognitionConfigFactory(
            name='Face Recognition Settings',
            version='2.0'
        )
        
        # Both versions should exist
        self.assertEqual(v1_config.version, '1.0')
        self.assertEqual(v2_config.version, '2.0')
        
        # Can query by version
        v2_configs = FaceRecognitionConfig.objects.filter(version='2.0')
        self.assertIn(v2_config, v2_configs)
    
    def test_environment_specific_configs(self):
        """Test environment-specific configurations"""
        dev_config = FaceRecognitionConfigFactory(
            name='Development Settings',
            environment='development',
            config_data={
                'similarity_threshold': 0.5,  # More lenient
                'enable_debug_logging': True,
                'mock_anti_spoofing': True
            }
        )
        
        prod_config = FaceRecognitionConfigFactory(
            name='Production Settings',
            environment='production',
            config_data={
                'similarity_threshold': 0.3,  # Strict
                'enable_debug_logging': False,
                'mock_anti_spoofing': False
            }
        )
        
        self.assertEqual(dev_config.environment, 'development')
        self.assertEqual(prod_config.environment, 'production')
        
        # Different thresholds for different environments
        self.assertGreater(
            dev_config.config_data['similarity_threshold'],
            prod_config.config_data['similarity_threshold']
        )