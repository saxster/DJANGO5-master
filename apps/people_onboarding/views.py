"""
Views for People Onboarding Module

Comprehensive views for onboarding workflow.
Complies with Rule #8: View methods < 30 lines
Complies with Rule #17: Transaction management
"""
from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.db import transaction
from django.db.models import Count, Q
from django.utils import timezone
from datetime import timedelta

from apps.core.utils_new.db_utils import get_current_db_name
from apps.peoples.models import People
from .models import (
    OnboardingRequest, CandidateProfile, DocumentSubmission,
    ApprovalWorkflow, OnboardingTask, BackgroundCheck,
    AccessProvisioning, TrainingAssignment
)
from .forms import CandidateProfileForm, DocumentUploadForm, ApprovalDecisionForm
from .services.document_parser_service import DocumentParserService


@login_required
def dashboard(request):
    """Onboarding dashboard with summary statistics"""
    from django.db.models import Avg

    stats = {
        'active': OnboardingRequest.objects.filter(
            current_state__in=['DRAFT', 'SUBMITTED', 'DOCUMENT_VERIFICATION', 'BACKGROUND_CHECK', 'PENDING_APPROVAL']
        ).count(),
        'pending_approval': ApprovalWorkflow.objects.filter(decision='PENDING').count(),
        'overdue': ApprovalWorkflow.objects.filter(
            decision='PENDING',
            sla_deadline__lt=timezone.now()
        ).count(),
        'completed_30days': OnboardingRequest.objects.filter(
            current_state='COMPLETED',
            actual_completion_date__gte=timezone.now() - timedelta(days=30)
        ).count(),
    }

    return render(request, 'people_onboarding/dashboard.html', {'stats': stats})


@login_required
def request_list(request):
    """List all onboarding requests"""
    requests = OnboardingRequest.objects.select_related(
        'candidate_profile', 'cdby'
    ).prefetch_related(
        'documents', 'approvals', 'tasks'
    ).order_by('-cdtz')

    return render(request, 'people_onboarding/request_list.html', {'requests': requests})


@login_required
def request_detail(request, uuid):
    """Detailed view of an onboarding request"""
    onboarding_request = get_object_or_404(
        OnboardingRequest.objects.select_related('candidate_profile').prefetch_related(
            'documents', 'approvals', 'tasks', 'background_checks',
            'access_provisioning', 'training_assignments'
        ),
        uuid=uuid
    )

    return render(request, 'people_onboarding/request_detail.html', {
        'request': onboarding_request
    })


@login_required
def start_onboarding(request):
    """Start new onboarding request - step 1: select person type and mode"""
    if request.method == 'POST':
        person_type = request.POST.get('person_type')
        mode = request.POST.get('mode', 'form')

        # Create new onboarding request
        with transaction.atomic(using=get_current_db_name()):
            # request_number auto-generated by model using PostgreSQL sequence
            onboarding_request = OnboardingRequest.objects.create(
                person_type=person_type,
                current_state='DRAFT',
                cdby=request.user
            )

            messages.success(
                request,
                f'Onboarding request {onboarding_request.request_number} created successfully.'
            )
            return redirect('people_onboarding:onboarding_wizard', uuid=onboarding_request.uuid)

    # Get draft requests
    draft_requests = OnboardingRequest.objects.filter(
        cdby=request.user,
        current_state='DRAFT'
    ).order_by('-cdtz')[:5]

    return render(request, 'people_onboarding/start_onboarding.html', {
        'draft_requests': draft_requests
    })


@login_required
def onboarding_wizard(request, uuid):
    """Multi-step onboarding wizard"""
    onboarding_request = get_object_or_404(OnboardingRequest, uuid=uuid)

    if request.method == 'POST':
        form = CandidateProfileForm(request.POST, request.FILES,
                                    instance=onboarding_request.candidate_profile)
        if form.is_valid():
            with transaction.atomic(using=get_current_db_name()):
                profile = form.save(commit=False)
                profile.cdby = request.user
                profile.save()

                # Link profile to request if not already linked
                if not onboarding_request.candidate_profile:
                    onboarding_request.candidate_profile = profile
                    onboarding_request.save()

                # Update state to SUBMITTED
                onboarding_request.current_state = 'SUBMITTED'
                onboarding_request.save()

                messages.success(request, 'Onboarding information submitted successfully.')
                return redirect('people_onboarding:request_detail', uuid=uuid)
    else:
        form = CandidateProfileForm(instance=onboarding_request.candidate_profile)

    return render(request, 'people_onboarding/onboarding_wizard.html', {
        'form': form,
        'request_obj': onboarding_request,
        'profile': onboarding_request.candidate_profile
    })


@login_required
def document_upload(request, uuid):
    """Upload documents for onboarding request"""
    onboarding_request = get_object_or_404(
        OnboardingRequest.objects.prefetch_related('documents'),
        uuid=uuid
    )

    documents = onboarding_request.submitted_documents.all().order_by('-cdtz')

    # Required document types (example list)
    required_documents = [
        {'code': 'RESUME', 'name': 'Resume/CV', 'description': 'Current resume or curriculum vitae', 'uploaded': False},
        {'code': 'ID_PROOF', 'name': 'Government ID', 'description': 'Passport, Driver License, or National ID', 'uploaded': False},
        {'code': 'EDUCATION', 'name': 'Education Certificates', 'description': 'Degree and transcripts', 'uploaded': False},
        {'code': 'EXPERIENCE', 'name': 'Experience Letters', 'description': 'Previous employment letters', 'uploaded': False},
    ]

    # Mark which documents are uploaded
    uploaded_types = set(doc.document_type for doc in documents)
    for doc_type in required_documents:
        doc_type['uploaded'] = doc_type['code'] in uploaded_types

    return render(request, 'people_onboarding/document_upload.html', {
        'request_obj': onboarding_request,
        'documents': documents,
        'required_documents': required_documents,
        'document_parser_available': DocumentParserService.is_available(),
    })


@login_required
def approval_list(request):
    """List approvals assigned to current user"""
    from django.db.models import F, ExpressionWrapper, DurationField

    approvals = ApprovalWorkflow.objects.filter(
        approver=request.user
    ).select_related(
        'onboarding_request__candidate_profile'
    ).annotate(
        sla_hours_remaining=ExpressionWrapper(
            F('sla_deadline') - timezone.now(),
            output_field=DurationField()
        )
    ).order_by('sla_deadline')

    # Calculate statistics
    stats = {
        'overdue': approvals.filter(decision='PENDING', sla_deadline__lt=timezone.now()).count(),
        'pending': approvals.filter(decision='PENDING').count(),
        'approved_today': approvals.filter(
            decision='APPROVED',
            decision_date__date=timezone.now().date()
        ).count(),
        'avg_decision_hours': 24.0  # Placeholder - calculate from actual data
    }

    return render(request, 'people_onboarding/approval_list.html', {
        'approvals': approvals,
        'stats': stats
    })


@login_required
def approval_decision(request, uuid):
    """Decide on an approval request"""
    approval = get_object_or_404(
        ApprovalWorkflow.objects.select_related('onboarding_request__candidate_profile'),
        uuid=uuid
    )

    # Permission check
    if approval.approver != request.user and not request.user.is_staff:
        messages.error(request, 'You do not have permission to make this decision.')
        return redirect('people_onboarding:approval_list')

    if request.method == 'POST':
        form = ApprovalDecisionForm(request.POST, approval_workflow=approval)
        if form.is_valid():
            with transaction.atomic(using=get_current_db_name()):
                decision = form.cleaned_data['decision']
                notes = form.cleaned_data['notes']
                ip_address = request.META.get('REMOTE_ADDR')

                if decision == 'APPROVED':
                    approval.approve(notes=notes, ip_address=ip_address)
                    messages.success(request, 'Request approved successfully.')
                elif decision == 'REJECTED':
                    approval.reject(notes=notes, ip_address=ip_address)
                    messages.warning(request, 'Request rejected.')
                elif decision == 'ESCALATED':
                    escalated_to = form.cleaned_data['escalated_to']
                    escalation_reason = form.cleaned_data['escalation_reason']
                    approval.escalate(
                        escalated_to=escalated_to,
                        reason=escalation_reason,
                        ip_address=ip_address
                    )
                    messages.info(request, f'Request escalated to {escalated_to.peoplename}.')

                return redirect('people_onboarding:approval_list')
    else:
        form = ApprovalDecisionForm(approval_workflow=approval)

    # Get related data
    documents = approval.onboarding_request.submitted_documents.all()

    return render(request, 'people_onboarding/approval_decision.html', {
        'approval': approval,
        'form': form,
        'documents': documents
    })


@login_required
def task_list(request, uuid):
    """View tasks for onboarding request"""
    onboarding_request = get_object_or_404(OnboardingRequest, uuid=uuid)
    tasks = onboarding_request.tasks.select_related('assigned_to').order_by('due_date')

    # Group tasks by status
    tasks_by_status = {
        'PENDING': tasks.filter(status='PENDING'),
        'IN_PROGRESS': tasks.filter(status='IN_PROGRESS'),
        'BLOCKED': tasks.filter(status='BLOCKED'),
        'COMPLETED': tasks.filter(status='COMPLETED'),
    }

    # Calculate statistics
    stats = {
        'pending': tasks.filter(status='PENDING').count(),
        'in_progress': tasks.filter(status='IN_PROGRESS').count(),
        'blocked': tasks.filter(status='BLOCKED').count(),
        'completed': tasks.filter(status='COMPLETED').count(),
    }

    # Get available assignees (staff users)
    assignees = People.objects.filter(is_staff=True, enable=True).order_by('peoplename')

    return render(request, 'people_onboarding/task_list.html', {
        'request_obj': onboarding_request,
        'tasks_by_status': tasks_by_status,
        'all_tasks': tasks,
        'stats': stats,
        'assignees': assignees
    })
