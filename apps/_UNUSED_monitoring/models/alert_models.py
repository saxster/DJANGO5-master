"""
Alert Management Models

Handles all alerting functionality including rules, instances, and acknowledgments.
Follows .claude/rules.md Rule #7: Model < 150 lines per class.
"""

from django.db import models
from django.conf import settings
from django.utils import timezone
from django.core.validators import MinValueValidator, MaxValueValidator
from apps.peoples.models import BaseModel
from apps.tenants.models import TenantAwareModel
import uuid


class AlertRule(BaseModel, TenantAwareModel):
    """
    Configurable rules for generating alerts based on device metrics.

    Supports complex conditions and dynamic thresholds.
    """

    ALERT_TYPES = [
        ('BATTERY_LOW', 'Battery Low'),
        ('BATTERY_CRITICAL', 'Battery Critical'),
        ('NO_MOVEMENT', 'No Movement Detected'),
        ('LOCATION_VIOLATION', 'Location Violation'),
        ('NETWORK_DOWN', 'Network Disconnected'),
        ('SIGNAL_POOR', 'Poor Signal Strength'),
        ('BIOMETRIC_FAILURE', 'Biometric Authentication Failure'),
        ('DEVICE_OVERHEATING', 'Device Overheating'),
        ('MEMORY_LOW', 'Low Memory'),
        ('STORAGE_FULL', 'Storage Full'),
        ('PERFORMANCE_DEGRADED', 'Performance Degraded'),
        ('CONCURRENT_USAGE', 'Concurrent Device Usage'),
        ('DATA_USAGE_SPIKE', 'Unusual Data Usage'),
        ('FRAUD_RISK', 'Fraud Risk Detected'),
    ]

    SEVERITY_LEVELS = [
        ('INFO', 'Information'),
        ('WARNING', 'Warning'),
        ('HIGH', 'High Priority'),
        ('CRITICAL', 'Critical'),
        ('EMERGENCY', 'Emergency'),
    ]

    rule_id = models.UUIDField(
        default=uuid.uuid4,
        unique=True,
        editable=False,
        help_text="Unique identifier for this alert rule"
    )

    name = models.CharField(
        max_length=200,
        help_text="Human-readable name for this rule"
    )

    alert_type = models.CharField(
        max_length=30,
        choices=ALERT_TYPES,
        db_index=True,
        help_text="Type of alert this rule generates"
    )

    severity = models.CharField(
        max_length=20,
        choices=SEVERITY_LEVELS,
        default='WARNING',
        db_index=True,
        help_text="Severity level for alerts generated by this rule"
    )

    is_active = models.BooleanField(
        default=True,
        db_index=True,
        help_text="Whether this rule is currently active"
    )

    conditions = models.JSONField(
        help_text="JSON object defining alert conditions and thresholds"
    )

    # Context-aware settings
    applies_to_sites = models.ManyToManyField(
        'onboarding.Bt',
        blank=True,
        help_text="Sites this rule applies to (empty = all sites)"
    )

    applies_to_roles = models.JSONField(
        default=list,
        help_text="User roles this rule applies to (empty = all roles)"
    )

    time_constraints = models.JSONField(
        default=dict,
        help_text="Time-based constraints (business hours, shifts, etc.)"
    )

    # Alert management
    cooldown_minutes = models.PositiveIntegerField(
        default=15,
        help_text="Minimum minutes between alerts for same condition"
    )

    auto_resolve_minutes = models.PositiveIntegerField(
        null=True,
        blank=True,
        help_text="Auto-resolve alert after N minutes (null = manual only)"
    )

    escalation_rules = models.JSONField(
        default=list,
        help_text="Escalation rules if alert not acknowledged"
    )

    # Notification settings
    notification_channels = models.JSONField(
        default=list,
        help_text="Channels to send notifications (email, sms, webhook, etc.)"
    )

    notification_template = models.TextField(
        blank=True,
        help_text="Custom notification message template"
    )

    # ML integration
    use_ml_thresholds = models.BooleanField(
        default=False,
        help_text="Use machine learning for dynamic thresholds"
    )

    ml_model_version = models.CharField(
        max_length=50,
        blank=True,
        help_text="Version of ML model used for this rule"
    )

    # Performance tracking
    total_triggered = models.PositiveIntegerField(
        default=0,
        help_text="Total number of times this rule has triggered"
    )

    false_positive_count = models.PositiveIntegerField(
        default=0,
        help_text="Number of false positives reported"
    )

    last_triggered = models.DateTimeField(
        null=True,
        blank=True,
        help_text="Last time this rule triggered an alert"
    )

    class Meta(BaseModel.Meta):
        db_table = 'monitoring_alert_rule'
        verbose_name = 'Alert Rule'
        verbose_name_plural = 'Alert Rules'
        indexes = [
            models.Index(fields=['tenant', 'alert_type', 'is_active']),
            models.Index(fields=['severity', 'is_active']),
            models.Index(fields=['last_triggered']),
        ]

    def __str__(self):
        return f"{self.name} ({self.alert_type})"

    def can_trigger(self, context_data=None):
        """Check if rule can trigger based on cooldown and conditions"""
        if not self.is_active:
            return False

        # Check cooldown period
        if self.last_triggered:
            cooldown_until = self.last_triggered + timezone.timedelta(
                minutes=self.cooldown_minutes
            )
            if timezone.now() < cooldown_until:
                return False

        # Check time constraints if provided
        if context_data and self.time_constraints:
            if not self._check_time_constraints(context_data):
                return False

        return True

    def _check_time_constraints(self, context_data):
        """Validate time-based constraints"""
        # Implementation for business hours, shift times, etc.
        return True


class Alert(BaseModel, TenantAwareModel):
    """
    Active alert instance with real-time status tracking.

    Represents a specific alert occurrence that requires attention.
    """

    STATUS_CHOICES = [
        ('ACTIVE', 'Active'),
        ('ACKNOWLEDGED', 'Acknowledged'),
        ('RESOLVED', 'Resolved'),
        ('FALSE_POSITIVE', 'False Positive'),
        ('SUPPRESSED', 'Suppressed'),
    ]

    alert_id = models.UUIDField(
        default=uuid.uuid4,
        unique=True,
        editable=False,
        help_text="Unique identifier for this alert"
    )

    rule = models.ForeignKey(
        AlertRule,
        on_delete=models.CASCADE,
        related_name='alerts',
        help_text="Alert rule that generated this alert"
    )

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='monitoring_alerts',
        help_text="User this alert is about"
    )

    device_id = models.CharField(
        max_length=100,
        db_index=True,
        help_text="Device that triggered the alert"
    )

    site = models.ForeignKey(
        'onboarding.Bt',
        on_delete=models.CASCADE,
        related_name='monitoring_alerts',
        help_text="Site where alert occurred"
    )

    status = models.CharField(
        max_length=20,
        choices=STATUS_CHOICES,
        default='ACTIVE',
        db_index=True,
        help_text="Current status of the alert"
    )

    severity = models.CharField(
        max_length=20,
        choices=AlertRule.SEVERITY_LEVELS,
        db_index=True,
        help_text="Severity level of this alert"
    )

    # Alert content
    title = models.CharField(
        max_length=200,
        help_text="Brief alert title"
    )

    description = models.TextField(
        help_text="Detailed alert description"
    )

    alert_data = models.JSONField(
        help_text="Raw data that triggered the alert"
    )

    context_data = models.JSONField(
        default=dict,
        help_text="Additional context about the alert"
    )

    # Timing
    triggered_at = models.DateTimeField(
        auto_now_add=True,
        db_index=True,
        help_text="When the alert was triggered"
    )

    acknowledged_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="When the alert was acknowledged"
    )

    resolved_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="When the alert was resolved"
    )

    # Alert management
    acknowledged_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='acknowledged_alerts',
        help_text="User who acknowledged this alert"
    )

    resolved_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='resolved_alerts',
        help_text="User who resolved this alert"
    )

    resolution_notes = models.TextField(
        blank=True,
        help_text="Notes about how the alert was resolved"
    )

    # Escalation tracking
    escalation_level = models.PositiveIntegerField(
        default=0,
        help_text="Current escalation level (0 = initial)"
    )

    next_escalation_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="When to escalate if not acknowledged"
    )

    # Performance metrics
    response_time_seconds = models.PositiveIntegerField(
        null=True,
        blank=True,
        help_text="Time to acknowledge in seconds"
    )

    resolution_time_seconds = models.PositiveIntegerField(
        null=True,
        blank=True,
        help_text="Time to resolve in seconds"
    )

    class Meta(BaseModel.Meta):
        db_table = 'monitoring_alert'
        verbose_name = 'Alert'
        verbose_name_plural = 'Alerts'
        ordering = ['-triggered_at']
        indexes = [
            models.Index(fields=['tenant', 'status', 'severity']),
            models.Index(fields=['user', 'status', 'triggered_at']),
            models.Index(fields=['site', 'status', 'triggered_at']),
            models.Index(fields=['rule', 'triggered_at']),
            models.Index(fields=['next_escalation_at']),
        ]

    def __str__(self):
        return f"{self.title} - {self.user.peoplename} ({self.status})"

    def acknowledge(self, user, notes=""):
        """Acknowledge the alert"""
        if self.status == 'ACTIVE':
            self.status = 'ACKNOWLEDGED'
            self.acknowledged_by = user
            self.acknowledged_at = timezone.now()
            self.response_time_seconds = int(
                (self.acknowledged_at - self.triggered_at).total_seconds()
            )
            if notes:
                self.resolution_notes = notes
            self.save()

    def resolve(self, user, notes=""):
        """Resolve the alert"""
        if self.status in ['ACTIVE', 'ACKNOWLEDGED']:
            self.status = 'RESOLVED'
            self.resolved_by = user
            self.resolved_at = timezone.now()
            self.resolution_time_seconds = int(
                (self.resolved_at - self.triggered_at).total_seconds()
            )
            if notes:
                self.resolution_notes = notes
            self.save()

    @property
    def is_overdue(self):
        """Check if alert is overdue for escalation"""
        if self.status == 'ACTIVE' and self.next_escalation_at:
            return timezone.now() > self.next_escalation_at
        return False


class AlertInstance(BaseModel):
    """
    Historical record of alert evaluations.

    Tracks every time a rule is evaluated, whether it triggers or not.
    Used for analytics and rule optimization.
    """

    alert = models.ForeignKey(
        Alert,
        on_delete=models.CASCADE,
        related_name='instances',
        null=True,
        blank=True,
        help_text="Alert created (null if rule didn't trigger)"
    )

    rule = models.ForeignKey(
        AlertRule,
        on_delete=models.CASCADE,
        related_name='evaluations',
        help_text="Rule that was evaluated"
    )

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        help_text="User the evaluation was for"
    )

    device_id = models.CharField(
        max_length=100,
        help_text="Device that was evaluated"
    )

    triggered = models.BooleanField(
        help_text="Whether the rule triggered an alert"
    )

    evaluation_data = models.JSONField(
        help_text="Data used for rule evaluation"
    )

    threshold_values = models.JSONField(
        help_text="Threshold values at time of evaluation"
    )

    evaluation_score = models.FloatField(
        null=True,
        blank=True,
        help_text="Numerical score from rule evaluation (0-1)"
    )

    evaluated_at = models.DateTimeField(
        auto_now_add=True,
        db_index=True,
        help_text="When the evaluation occurred"
    )

    class Meta(BaseModel.Meta):
        db_table = 'monitoring_alert_instance'
        verbose_name = 'Alert Evaluation'
        verbose_name_plural = 'Alert Evaluations'
        indexes = [
            models.Index(fields=['rule', 'triggered', 'evaluated_at']),
            models.Index(fields=['user', 'evaluated_at']),
            models.Index(fields=['device_id', 'evaluated_at']),
        ]

    def __str__(self):
        action = "TRIGGERED" if self.triggered else "evaluated"
        return f"{self.rule.name} {action} for {self.user.peoplename}"


class AlertAcknowledgment(BaseModel):
    """
    Detailed acknowledgment tracking for alerts.

    Provides audit trail for alert handling and response times.
    """

    alert = models.ForeignKey(
        Alert,
        on_delete=models.CASCADE,
        related_name='acknowledgments',
        help_text="Alert that was acknowledged"
    )

    acknowledged_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        help_text="User who acknowledged the alert"
    )

    acknowledgment_method = models.CharField(
        max_length=50,
        choices=[
            ('DASHBOARD', 'Dashboard'),
            ('MOBILE_APP', 'Mobile App'),
            ('EMAIL', 'Email Reply'),
            ('SMS', 'SMS Reply'),
            ('API', 'API Call'),
            ('AUTO', 'Automatic'),
        ],
        help_text="How the alert was acknowledged"
    )

    notes = models.TextField(
        blank=True,
        help_text="Acknowledgment notes"
    )

    acknowledged_at = models.DateTimeField(
        auto_now_add=True,
        help_text="When acknowledgment was recorded"
    )

    response_time_seconds = models.PositiveIntegerField(
        help_text="Seconds from alert trigger to acknowledgment"
    )

    class Meta(BaseModel.Meta):
        db_table = 'monitoring_alert_acknowledgment'
        verbose_name = 'Alert Acknowledgment'
        verbose_name_plural = 'Alert Acknowledgments'
        indexes = [
            models.Index(fields=['alert', 'acknowledged_at']),
            models.Index(fields=['acknowledged_by', 'acknowledged_at']),
        ]

    def __str__(self):
        return f"ACK: {self.alert.title} by {self.acknowledged_by.peoplename}"