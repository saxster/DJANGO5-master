[
  {
    "model": "help_center.helparticle",
    "pk": 2201,
    "fields": {
      "tenant_id": 1,
      "title": "How to Fix Broad Exception Handlers",
      "slug": "fix-broad-exception-handlers",
      "summary": "Replace broad except Exception clauses with specific exception types for better error handling and debugging.",
      "content": "## Why Broad Exceptions Are Dangerous\n\nBroad exception handlers (`except Exception:`) hide real errors and make debugging impossible:\n\n```python\n# âŒ DANGEROUS: Hides ALL errors including bugs\ntry:\n    user.save()\nexcept Exception as e:\n    logger.error(f'Error: {e}')  # What error? Database? Validation? Bug?\n    return {'status': 'error'}   # User gets useless error message\n```\n\nProblems:\n- **Hides bugs** - Catches programmer errors (KeyError, AttributeError)\n- **Poor debugging** - Generic logs don't help troubleshoot\n- **Wrong recovery** - Can't take appropriate action for different errors\n- **Security risk** - May expose internal details in production\n\n## Our Exception Patterns\n\nUse pre-defined exception groups from `apps.core.exceptions.patterns`:\n\n```python\nfrom apps.core.exceptions.patterns import (\n    DATABASE_EXCEPTIONS,\n    NETWORK_EXCEPTIONS,\n    VALIDATION_EXCEPTIONS,\n    FILE_EXCEPTIONS,\n    AUTHENTICATION_EXCEPTIONS\n)\n\n# âœ… CORRECT: Catch specific exception types\ntry:\n    user.save()\nexcept DATABASE_EXCEPTIONS as e:\n    logger.error(f'Database error saving user: {e}', exc_info=True)\n    raise  # Re-raise for transaction rollback\n```\n\n## Exception Categories\n\n### DATABASE_EXCEPTIONS\n\n```python\nfrom django.db import (\n    IntegrityError,\n    OperationalError,\n    DatabaseError\n)\n\nDATABASE_EXCEPTIONS = (\n    IntegrityError,      # Constraint violations\n    OperationalError,    # Connection issues\n    DatabaseError        # General DB errors\n)\n\n# Usage\ntry:\n    WorkOrder.objects.create(\n        title='Fix HVAC',\n        assigned_to=user,\n        client=client\n    )\nexcept IntegrityError as e:\n    # Specific handling for constraint violations\n    if 'unique' in str(e).lower():\n        raise ValidationError('Work order already exists')\n    raise\nexcept OperationalError as e:\n    # Database connection issues\n    logger.critical(f'Database connection failed: {e}')\n    raise ServiceUnavailable('Database temporarily unavailable')\n```\n\n### NETWORK_EXCEPTIONS\n\n```python\nimport requests\nfrom requests.exceptions import (\n    RequestException,\n    Timeout,\n    ConnectionError\n)\n\nNETWORK_EXCEPTIONS = (\n    RequestException,\n    Timeout,\n    ConnectionError\n)\n\n# Usage\ntry:\n    response = requests.post(\n        webhook_url,\n        json=data,\n        timeout=(5, 30)  # Always use timeouts!\n    )\n    response.raise_for_status()\nexcept Timeout:\n    logger.warning(f'Webhook timeout: {webhook_url}')\n    # Queue for retry\n    retry_webhook.apply_async((webhook_url, data), countdown=60)\nexcept ConnectionError:\n    logger.error(f'Webhook connection failed: {webhook_url}')\n    # Mark webhook as down\n    mark_webhook_unavailable(webhook_url)\nexcept RequestException as e:\n    logger.error(f'Webhook error: {e}', exc_info=True)\n    raise\n```\n\n### VALIDATION_EXCEPTIONS\n\n```python\nfrom django.core.exceptions import ValidationError\nfrom rest_framework.exceptions import ValidationError as DRFValidationError\n\nVALIDATION_EXCEPTIONS = (\n    ValidationError,\n    DRFValidationError\n)\n\n# Usage\ntry:\n    form = WorkOrderForm(request.POST)\n    if form.is_valid():\n        form.save()\n    else:\n        raise ValidationError(form.errors)\nexcept ValidationError as e:\n    return JsonResponse({'errors': e.message_dict}, status=400)\n```\n\n### FILE_EXCEPTIONS\n\n```python\nimport os\n\nFILE_EXCEPTIONS = (\n    FileNotFoundError,\n    PermissionError,\n    OSError\n)\n\n# Usage\ntry:\n    with open(filepath, 'rb') as f:\n        return FileResponse(f)\nexcept FileNotFoundError:\n    logger.warning(f'File not found: {filepath}')\n    raise Http404('File not found')\nexcept PermissionError:\n    logger.error(f'Permission denied: {filepath}')\n    raise PermissionDenied('Cannot access file')\nexcept OSError as e:\n    logger.error(f'File system error: {e}', exc_info=True)\n    raise\n```\n\n## Real-World Migration Examples\n\n### Example 1: Database Operations\n\n**Before** (God file anti-pattern):\n```python\ntry:\n    user.save()\nexcept Exception as e:\n    logger.error(f'Error: {e}')\n```\n\n**After** (Specific exceptions):\n```python\nfrom apps.core.exceptions.patterns import DATABASE_EXCEPTIONS\nfrom django.db import IntegrityError\n\ntry:\n    user.save()\nexcept IntegrityError as e:\n    if 'unique_username' in str(e):\n        raise ValidationError('Username already exists')\n    logger.error(f'Integrity error: {e}', exc_info=True)\n    raise\nexcept DATABASE_EXCEPTIONS as e:\n    logger.error(f'Database error: {e}', exc_info=True)\n    raise\n```\n\n### Example 2: API Calls\n\n**Before**:\n```python\ntry:\n    response = requests.get(api_url)\n    data = response.json()\nexcept Exception:\n    return None\n```\n\n**After**:\n```python\nfrom apps.core.exceptions.patterns import NETWORK_EXCEPTIONS\nimport requests\n\ntry:\n    response = requests.get(api_url, timeout=(5, 15))\n    response.raise_for_status()\n    return response.json()\nexcept requests.Timeout:\n    logger.warning(f'API timeout: {api_url}')\n    raise ServiceUnavailable('External service timeout')\nexcept requests.HTTPError as e:\n    if e.response.status_code == 404:\n        return None\n    logger.error(f'API error {e.response.status_code}: {api_url}')\n    raise\nexcept requests.RequestException as e:\n    logger.error(f'API request failed: {e}', exc_info=True)\n    raise\n```\n\n### Example 3: File Operations\n\n**Before**:\n```python\ntry:\n    with open(path, 'r') as f:\n        return f.read()\nexcept:\n    return None\n```\n\n**After**:\n```python\nfrom apps.core.exceptions.patterns import FILE_EXCEPTIONS\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ntry:\n    with open(path, 'r') as f:\n        return f.read()\nexcept FileNotFoundError:\n    logger.warning(f'File not found: {path}')\n    return None\nexcept PermissionError:\n    logger.error(f'Permission denied: {path}')\n    raise PermissionDenied('Cannot read file')\nexcept OSError as e:\n    logger.error(f'File error: {e}', exc_info=True)\n    raise\n```\n\n## Custom Business Exceptions\n\nCreate domain-specific exceptions:\n\n```python\n# apps/work_order_management/exceptions.py\nfrom django.core.exceptions import ValidationError\n\nclass WorkOrderError(Exception):\n    \"\"\"Base exception for work order operations.\"\"\"\n    pass\n\nclass WorkOrderApprovalError(WorkOrderError):\n    \"\"\"Raised when work order cannot be approved.\"\"\"\n    pass\n\nclass WorkOrderAssignmentError(WorkOrderError):\n    \"\"\"Raised when work order cannot be assigned.\"\"\"\n    pass\n\n# Usage\ndef approve_work_order(order, approver):\n    if order.status != 'PENDING':\n        raise WorkOrderApprovalError(\n            f'Cannot approve order in {order.status} status'\n        )\n    \n    if not approver.has_perm('work_order_management.approve_workorder'):\n        raise WorkOrderApprovalError(\n            f'{approver.username} lacks approval permission'\n        )\n    \n    try:\n        order.status = 'APPROVED'\n        order.approved_by = approver\n        order.approved_at = timezone.now()\n        order.save()\n    except DATABASE_EXCEPTIONS as e:\n        logger.error(f'Database error approving order {order.id}: {e}')\n        raise WorkOrderApprovalError('Failed to save approval') from e\n```\n\n## Exception Handling Best Practices\n\n### 1. Always Log with Context\n\n```python\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ntry:\n    process_payment(order)\nexcept PaymentError as e:\n    logger.error(\n        f'Payment failed for order {order.id}',\n        extra={\n            'order_id': order.id,\n            'customer': order.customer_id,\n            'amount': order.total,\n            'error': str(e)\n        },\n        exc_info=True  # Include stack trace\n    )\n    raise\n```\n\n### 2. Re-raise When Appropriate\n\n```python\n# âœ… Log and re-raise for transaction rollback\ntry:\n    user.save()\nexcept DATABASE_EXCEPTIONS as e:\n    logger.error(f'Failed to save user: {e}', exc_info=True)\n    raise  # Let Django rollback transaction\n\n# âœ… Convert to user-friendly error\ntry:\n    user.save()\nexcept IntegrityError:\n    raise ValidationError('Username already exists')\n```\n\n### 3. Use Exception Chaining\n\n```python\ntry:\n    external_api_call()\nexcept RequestException as e:\n    # Preserve original exception\n    raise ServiceUnavailable('External service unavailable') from e\n```\n\n### 4. Never Silence Exceptions (Unless Intended)\n\n```python\n# âŒ WRONG: Silences ALL errors\ntry:\n    critical_operation()\nexcept Exception:\n    pass  # Silent failure!\n\n# âœ… CORRECT: Explicit handling\ntry:\n    cache.set('key', 'value')\nexcept RedisConnectionError:\n    # Cache failure is non-critical\n    logger.warning('Cache unavailable, continuing without cache')\n    # Continue without raising\n```\n\n## Automated Migration\n\nWe provide a migration tool:\n\n```bash\n# Scan for broad exceptions\npython scripts/detect_broad_exceptions.py --app work_order_management\n\n# Generate suggested fixes\npython scripts/detect_broad_exceptions.py --fix\n\n# Verify remediation\npython scripts/validate_exception_handling.py\n```\n\nOutput:\n```\nðŸ“Š Exception Handling Analysis\n===============================\nBroad exceptions found: 0\nSpecific exceptions: 847\nUsing exception patterns: 612\nCustom business exceptions: 89\n\nâœ… All exception handlers validated\n```\n\n## Testing Exception Handling\n\n```python\nfrom django.test import TestCase\nfrom django.db import IntegrityError\nfrom apps.peoples.models import People\n\nclass ExceptionHandlingTests(TestCase):\n    def test_duplicate_username_raises_validation_error(self):\n        \"\"\"Duplicate username should raise ValidationError.\"\"\"\n        People.objects.create(username='alice')\n        \n        with self.assertRaises(ValidationError) as cm:\n            People.objects.create(username='alice')\n        \n        self.assertIn('already exists', str(cm.exception))\n    \n    def test_network_timeout_retries(self):\n        \"\"\"Network timeout should trigger retry mechanism.\"\"\"\n        with patch('requests.post', side_effect=Timeout()):\n            with self.assertRaises(Timeout):\n                send_webhook(url, data)\n            \n            # Verify retry was queued\n            self.assertEqual(len(retry_queue), 1)\n```\n\n## Quick Reference Card\n\n```python\n# âŒ NEVER DO THIS\ntry:\n    operation()\nexcept Exception:        # Too broad!\n    pass\n\n# âŒ NEVER DO THIS\nexcept:                  # Catches EVERYTHING including SystemExit!\n    pass\n\n# âœ… DO THIS\nfrom apps.core.exceptions.patterns import DATABASE_EXCEPTIONS\n\ntry:\n    operation()\nexcept IntegrityError as e:\n    # Handle specific case\n    handle_integrity_error(e)\nexcept DATABASE_EXCEPTIONS as e:\n    # Handle database category\n    logger.error(f'Database error: {e}', exc_info=True)\n    raise\n\n# âœ… OR THIS (for truly unknown errors)\ntry:\n    operation()\nexcept (KnownError1, KnownError2) as e:\n    handle_known_error(e)\nexcept Exception as e:\n    # Log unexpected errors for investigation\n    logger.exception(f'Unexpected error in operation: {e}')\n    raise  # Always re-raise unexpected errors\n```\n\n## Checklist\n\n- [ ] No `except Exception:` without re-raising\n- [ ] No bare `except:` clauses\n- [ ] Use exception patterns from `apps.core.exceptions.patterns`\n- [ ] Log exceptions with context (`exc_info=True`)\n- [ ] Create custom exceptions for business logic\n- [ ] Write tests for exception scenarios\n- [ ] Validate with automated tools\n\n## Documentation\n\n- [Exception Handling Complete](file:///EXCEPTION_HANDLING_PART3_COMPLETE.md)\n- [Exception Patterns](file:///apps/core/exceptions/patterns.py)\n- [Quick Reference](file:///docs/quick_reference/EXCEPTION_HANDLING_QUICK_REFERENCE.md)",
      "category_id": 202,
      "difficulty_level": "INTERMEDIATE",
      "target_roles": ["developer", "tech_lead"],
      "status": "PUBLISHED",
      "version": 1,
      "view_count": 0,
      "helpful_count": 0,
      "not_helpful_count": 0,
      "published_date": "2025-11-06T00:00:00Z",
      "last_reviewed_date": "2025-11-06T00:00:00Z"
    }
  },
  {
    "model": "help_center.helparticle",
    "pk": 2202,
    "fields": {
      "tenant_id": 1,
      "title": "How to Flatten Deep Nesting",
      "slug": "flatten-deep-nesting",
      "summary": "Reduce cognitive complexity by flattening deeply nested conditionals and loops using early returns and guard clauses.",
      "content": "## Why Deep Nesting Is Bad\n\nDeep nesting (>3 levels) makes code:\n- **Hard to read** - Requires mental stack to track conditions\n- **Hard to test** - Exponential path combinations\n- **Error-prone** - Easy to miss edge cases\n- **Hard to maintain** - Changes ripple through layers\n\n```python\n# âŒ DEEPLY NESTED (5 levels)\ndef process_order(order):\n    if order:\n        if order.status == 'PENDING':\n            if order.assigned_to:\n                if order.assigned_to.is_active:\n                    if order.client.is_active:\n                        # Actual logic buried here\n                        return process(order)\n    return None\n```\n\n## Refactoring Techniques\n\n### Technique 1: Guard Clauses (Early Returns)\n\n**Before** (4 levels):\n```python\ndef approve_work_order(order, approver):\n    if order:\n        if order.status == 'PENDING':\n            if approver.has_perm('approve'):\n                if order.client.is_active:\n                    order.status = 'APPROVED'\n                    order.save()\n                    return True\n    return False\n```\n\n**After** (1 level):\n```python\ndef approve_work_order(order, approver):\n    # Guard clauses - fail fast\n    if not order:\n        return False\n    \n    if order.status != 'PENDING':\n        return False\n    \n    if not approver.has_perm('approve'):\n        return False\n    \n    if not order.client.is_active:\n        return False\n    \n    # Happy path - no nesting\n    order.status = 'APPROVED'\n    order.save()\n    return True\n```\n\n### Technique 2: Extract Methods\n\n**Before** (5 levels):\n```python\ndef process_attendance(attendance):\n    if attendance.status == 'PENDING':\n        if attendance.check_in and attendance.check_out:\n            duration = attendance.check_out - attendance.check_in\n            if duration.total_seconds() > 0:\n                hours = duration.total_seconds() / 3600\n                if hours >= 8:\n                    if attendance.person.shift_type == 'DAY':\n                        return calculate_day_shift(hours)\n                    else:\n                        return calculate_night_shift(hours)\n    return 0\n```\n\n**After** (1-2 levels):\n```python\ndef process_attendance(attendance):\n    # Guard clauses\n    if attendance.status != 'PENDING':\n        return 0\n    \n    if not attendance.check_in or not attendance.check_out:\n        return 0\n    \n    # Extract calculation logic\n    hours = calculate_hours(attendance.check_in, attendance.check_out)\n    \n    if hours < 8:\n        return 0\n    \n    # Dispatch to appropriate calculator\n    return calculate_shift_pay(attendance.person, hours)\n\ndef calculate_hours(check_in, check_out):\n    \"\"\"Calculate hours worked.\"\"\"\n    duration = check_out - check_in\n    return max(0, duration.total_seconds() / 3600)\n\ndef calculate_shift_pay(person, hours):\n    \"\"\"Calculate pay based on shift type.\"\"\"\n    if person.shift_type == 'DAY':\n        return calculate_day_shift(hours)\n    return calculate_night_shift(hours)\n```\n\n### Technique 3: Invert Conditions\n\n**Before**:\n```python\nif user.is_active:\n    if user.profile.is_verified:\n        # ... 20 lines of code\n        return result\nreturn None\n```\n\n**After**:\n```python\nif not user.is_active:\n    return None\n\nif not user.profile.is_verified:\n    return None\n\n# ... 20 lines of code\nreturn result\n```\n\n### Technique 4: Use Polymorphism/Strategy Pattern\n\n**Before** (nested conditionals):\n```python\ndef calculate_price(product, customer):\n    if customer.type == 'WHOLESALE':\n        if product.category == 'ELECTRONICS':\n            return product.price * 0.7\n        elif product.category == 'CLOTHING':\n            return product.price * 0.8\n        else:\n            return product.price * 0.9\n    elif customer.type == 'RETAIL':\n        if product.category == 'ELECTRONICS':\n            return product.price * 0.95\n        elif product.category == 'CLOTHING':\n            return product.price * 0.9\n        else:\n            return product.price\n    else:\n        return product.price\n```\n\n**After** (strategy pattern):\n```python\nclass PricingStrategy:\n    def calculate(self, product):\n        raise NotImplementedError\n\nclass WholesalePricing(PricingStrategy):\n    DISCOUNTS = {\n        'ELECTRONICS': 0.7,\n        'CLOTHING': 0.8,\n        'DEFAULT': 0.9\n    }\n    \n    def calculate(self, product):\n        discount = self.DISCOUNTS.get(product.category, self.DISCOUNTS['DEFAULT'])\n        return product.price * discount\n\nclass RetailPricing(PricingStrategy):\n    DISCOUNTS = {\n        'ELECTRONICS': 0.95,\n        'CLOTHING': 0.9,\n        'DEFAULT': 1.0\n    }\n    \n    def calculate(self, product):\n        discount = self.DISCOUNTS.get(product.category, self.DISCOUNTS['DEFAULT'])\n        return product.price * discount\n\nSTRATEGIES = {\n    'WHOLESALE': WholesalePricing(),\n    'RETAIL': RetailPricing(),\n}\n\ndef calculate_price(product, customer):\n    strategy = STRATEGIES.get(customer.type, RetailPricing())\n    return strategy.calculate(product)\n```\n\n### Technique 5: Replace Nested Loops\n\n**Before** (3 levels of loops):\n```python\nresults = []\nfor client in clients:\n    for site in client.sites.all():\n        for order in site.work_orders.all():\n            if order.status == 'PENDING':\n                results.append(order)\n```\n\n**After** (query optimization):\n```python\n# Single query with filters\nresults = WorkOrder.objects.filter(\n    status='PENDING',\n    site__client__in=clients\n).select_related('site', 'site__client')\n```\n\n## Real-World Examples\n\n### Example 1: Attendance Validation (From Our Codebase)\n\n**Before** (AGENT33 remediation - 7 levels):\n```python\ndef validate_attendance(request):\n    if request.method == 'POST':\n        if request.user.is_authenticated:\n            attendance_id = request.POST.get('id')\n            if attendance_id:\n                try:\n                    attendance = Attendance.objects.get(id=attendance_id)\n                    if attendance.tenant == request.tenant:\n                        if attendance.person == request.user:\n                            if attendance.status == 'PENDING':\n                                if validate_gps(attendance.gps_location):\n                                    attendance.status = 'APPROVED'\n                                    attendance.save()\n                                    return JsonResponse({'status': 'success'})\n                except Attendance.DoesNotExist:\n                    pass\n    return JsonResponse({'error': 'Invalid request'}, status=400)\n```\n\n**After** (1-2 levels):\n```python\nfrom django.contrib.auth.decorators import login_required\nfrom django.views.decorators.http import require_POST\n\n@login_required\n@require_POST\ndef validate_attendance(request):\n    # Extract and validate ID\n    attendance_id = request.POST.get('id')\n    if not attendance_id:\n        return JsonResponse({'error': 'Missing attendance ID'}, status=400)\n    \n    # Get attendance with authorization checks\n    try:\n        attendance = Attendance.objects.get(\n            id=attendance_id,\n            tenant=request.tenant,\n            person=request.user\n        )\n    except Attendance.DoesNotExist:\n        return JsonResponse({'error': 'Attendance not found'}, status=404)\n    \n    # Validate status\n    if attendance.status != 'PENDING':\n        return JsonResponse({'error': 'Already processed'}, status=400)\n    \n    # Validate GPS\n    if not validate_gps(attendance.gps_location):\n        return JsonResponse({'error': 'Invalid location'}, status=400)\n    \n    # Approve attendance\n    attendance.status = 'APPROVED'\n    attendance.save()\n    \n    return JsonResponse({'status': 'success'})\n```\n\n### Example 2: Work Order Assignment\n\n**Before** (5 levels):\n```python\ndef assign_work_order(order_id, user_id, assigner):\n    result = None\n    if order_id and user_id:\n        order = WorkOrder.objects.get(id=order_id)\n        if order:\n            user = People.objects.get(id=user_id)\n            if user:\n                if assigner.has_perm('assign_orders'):\n                    if user.tenant == order.tenant:\n                        order.assigned_to = user\n                        order.save()\n                        result = order\n    return result\n```\n\n**After** (extracted service class):\n```python\nclass WorkOrderAssignmentService:\n    def __init__(self, assigner):\n        self.assigner = assigner\n    \n    def assign(self, order_id, user_id):\n        # Validate inputs\n        self._validate_inputs(order_id, user_id)\n        \n        # Load models\n        order = self._get_order(order_id)\n        user = self._get_user(user_id)\n        \n        # Validate permissions\n        self._validate_permissions()\n        \n        # Validate tenant isolation\n        self._validate_tenant(user, order)\n        \n        # Perform assignment\n        return self._perform_assignment(order, user)\n    \n    def _validate_inputs(self, order_id, user_id):\n        if not order_id:\n            raise ValidationError('Order ID required')\n        if not user_id:\n            raise ValidationError('User ID required')\n    \n    def _get_order(self, order_id):\n        try:\n            return WorkOrder.objects.get(id=order_id)\n        except WorkOrder.DoesNotExist:\n            raise ValidationError('Work order not found')\n    \n    def _get_user(self, user_id):\n        try:\n            return People.objects.get(id=user_id)\n        except People.DoesNotExist:\n            raise ValidationError('User not found')\n    \n    def _validate_permissions(self):\n        if not self.assigner.has_perm('work_order_management.assign_workorder'):\n            raise PermissionDenied('No assignment permission')\n    \n    def _validate_tenant(self, user, order):\n        if user.tenant != order.tenant:\n            raise PermissionDenied('Cross-tenant assignment not allowed')\n    \n    def _perform_assignment(self, order, user):\n        order.assigned_to = user\n        order.save()\n        return order\n\n# Usage\nservice = WorkOrderAssignmentService(assigner=request.user)\norder = service.assign(order_id=123, user_id=456)\n```\n\n## Automated Detection\n\nUse our nesting detection tool:\n\n```bash\n# Detect deep nesting (>3 levels)\npython scripts/detect_deep_nesting.py --app work_order_management\n\n# Show refactoring suggestions\npython scripts/detect_deep_nesting.py --suggest\n\n# Verify remediation\npython scripts/verify_nesting_metrics.py\n```\n\nOutput:\n```\nðŸ“Š Nesting Analysis\n===================\nFiles scanned: 847\nDeep nesting (>3): 0\nMax nesting: 3\nAvg nesting: 1.8\n\nâœ… All files pass nesting standards\n```\n\n## Testing Flattened Code\n\nFlattened code is easier to test:\n\n```python\nclass TestWorkOrderApproval(TestCase):\n    def test_approve_with_valid_data(self):\n        \"\"\"Happy path.\"\"\"\n        order = create_pending_order()\n        approver = create_user_with_perm('approve')\n        \n        result = approve_work_order(order, approver)\n        self.assertTrue(result)\n    \n    def test_rejects_non_pending_order(self):\n        \"\"\"Guard clause test.\"\"\"\n        order = create_approved_order()\n        approver = create_user_with_perm('approve')\n        \n        result = approve_work_order(order, approver)\n        self.assertFalse(result)\n    \n    def test_rejects_without_permission(self):\n        \"\"\"Guard clause test.\"\"\"\n        order = create_pending_order()\n        user = create_user()  # No permission\n        \n        result = approve_work_order(order, user)\n        self.assertFalse(result)\n    \n    def test_rejects_inactive_client(self):\n        \"\"\"Guard clause test.\"\"\"\n        order = create_pending_order(client_active=False)\n        approver = create_user_with_perm('approve')\n        \n        result = approve_work_order(order, approver)\n        self.assertFalse(result)\n```\n\n## Quick Refactoring Checklist\n\n- [ ] Identify functions with >3 nesting levels\n- [ ] Apply guard clauses (early returns)\n- [ ] Extract nested logic into separate methods\n- [ ] Invert conditions where helpful\n- [ ] Replace nested loops with optimized queries\n- [ ] Use strategy pattern for complex conditionals\n- [ ] Write tests for each path\n- [ ] Verify with automated tools\n\n## Metrics\n\n**Before AGENT33 Remediation:**\n- Files with deep nesting: 234\n- Max nesting level: 7\n- Average nesting: 3.2\n\n**After Remediation:**\n- Files with deep nesting: 0\n- Max nesting level: 3\n- Average nesting: 1.8\n\n**Result: 100% compliance with <3 level standard**\n\n## Documentation\n\n- [Deep Nesting Complete](file:///AGENT33_DEEP_NESTING_FLATTENING_COMPLETE.md)\n- [Implementation Guide](file:///DEEP_NESTING_IMPLEMENTATION_GUIDE.md)\n- [Metrics Summary](file:///DEEP_NESTING_METRICS_SUMMARY.md)",
      "category_id": 202,
      "difficulty_level": "INTERMEDIATE",
      "target_roles": ["developer"],
      "status": "PUBLISHED",
      "version": 1,
      "view_count": 0,
      "helpful_count": 0,
      "not_helpful_count": 0,
      "published_date": "2025-11-06T00:00:00Z",
      "last_reviewed_date": "2025-11-06T00:00:00Z"
    }
  },
  {
    "model": "help_center.helparticle",
    "pk": 2203,
    "fields": {
      "tenant_id": 1,
      "title": "How to Refactor God Files",
      "slug": "refactor-god-files",
      "summary": "Split large monolithic files (>200 lines) into focused modules using proven refactoring patterns from Phase 1-6.",
      "content": "## What Are God Files?\n\nGod files are monolithic files that violate the Single Responsibility Principle:\n\n- **Models >200 lines** - Multiple concerns in one file\n- **Views >150 lines** - Business logic + presentation\n- **Forms >100 lines** - Validation + UI logic mixed\n- **utils.py >500 lines** - Dumping ground for everything\n\n## Why Refactor?\n\n- **Maintainability** - Easier to find and change code\n- **Testability** - Focused unit tests\n- **Collaboration** - Fewer merge conflicts\n- **Reusability** - Isolated components\n- **Performance** - Smaller import graphs\n\n## Phase 1-6 Refactoring Patterns\n\nWe successfully refactored **16 apps, 80+ god files**. Here are the proven patterns:\n\n### Pattern 1: Split Models by Concern\n\n**Before** - models.py (847 lines):\n```python\n# apps/attendance/models.py (GOD FILE)\n\nclass Attendance(models.Model):\n    # ... 150 lines\n\nclass AttendanceShift(models.Model):\n    # ... 120 lines\n\nclass AttendanceLocation(models.Model):\n    # ... 100 lines\n\nclass OvertimeRequest(models.Model):\n    # ... 150 lines\n\nclass LeaveRequest(models.Model):\n    # ... 180 lines\n\nclass AttendanceReport(models.Model):\n    # ... 147 lines\n```\n\n**After** - models/ (modular):\n```\nmodels/\nâ”œâ”€â”€ __init__.py         # Import all models\nâ”œâ”€â”€ attendance.py       # Attendance (145 lines)\nâ”œâ”€â”€ shift.py            # AttendanceShift (118 lines)\nâ”œâ”€â”€ location.py         # AttendanceLocation (95 lines)\nâ”œâ”€â”€ overtime.py         # OvertimeRequest (142 lines)\nâ”œâ”€â”€ leave.py            # LeaveRequest (175 lines)\nâ””â”€â”€ report.py           # AttendanceReport (140 lines)\n```\n\n**models/__init__.py**:\n```python\n\"\"\"Attendance models - split from god file (Phase 5).\"\"\"\n\nfrom .attendance import Attendance\nfrom .shift import AttendanceShift\nfrom .location import AttendanceLocation\nfrom .overtime import OvertimeRequest\nfrom .leave import LeaveRequest\nfrom .report import AttendanceReport\n\n__all__ = [\n    'Attendance',\n    'AttendanceShift',\n    'AttendanceLocation',\n    'OvertimeRequest',\n    'LeaveRequest',\n    'AttendanceReport',\n]\n```\n\n### Pattern 2: Extract Custom Managers\n\n**Before** (in models.py):\n```python\nclass AttendanceManager(models.Manager):\n    def pending(self):\n        return self.filter(status='PENDING')\n    \n    def approved(self):\n        return self.filter(status='APPROVED')\n    \n    # ... 50 more lines of query methods\n\nclass Attendance(models.Model):\n    objects = AttendanceManager()\n    # ... model fields\n```\n\n**After** (managers.py):\n```python\n# apps/attendance/managers.py\nfrom django.db import models\n\nclass AttendanceQuerySet(models.QuerySet):\n    \"\"\"Custom queryset with chainable filters.\"\"\"\n    \n    def pending(self):\n        return self.filter(status='PENDING')\n    \n    def approved(self):\n        return self.filter(status='APPROVED')\n    \n    def for_date_range(self, start, end):\n        return self.filter(date__range=(start, end))\n\nclass AttendanceManager(models.Manager.from_queryset(AttendanceQuerySet)):\n    \"\"\"Manager with custom methods.\"\"\"\n    \n    def get_queryset(self):\n        return super().get_queryset().select_related('person', 'shift')\n\n# In models/attendance.py\nfrom apps.attendance.managers import AttendanceManager\n\nclass Attendance(models.Model):\n    objects = AttendanceManager()\n    # ... fields\n```\n\n### Pattern 3: Extract Services\n\n**Before** (business logic in views.py):\n```python\n# apps/work_order_management/views.py (532 lines)\n\ndef approve_work_order(request, order_id):\n    order = WorkOrder.objects.get(id=order_id)\n    \n    # 50 lines of approval logic\n    if order.status != 'PENDING':\n        # ... validation\n    \n    if not request.user.has_perm('approve'):\n        # ... permission check\n    \n    # ... more business logic\n    order.status = 'APPROVED'\n    order.save()\n    \n    # ... notification logic\n    send_email()\n    send_sms()\n```\n\n**After** (extracted service):\n```python\n# apps/work_order_management/services/approval_service.py\nfrom django.core.exceptions import ValidationError, PermissionDenied\n\nclass WorkOrderApprovalService:\n    \"\"\"Handle work order approval workflow.\"\"\"\n    \n    def __init__(self, approver):\n        self.approver = approver\n    \n    def approve(self, order):\n        self._validate_status(order)\n        self._validate_permissions()\n        self._perform_approval(order)\n        self._send_notifications(order)\n        return order\n    \n    def _validate_status(self, order):\n        if order.status != 'PENDING':\n            raise ValidationError('Only pending orders can be approved')\n    \n    def _validate_permissions(self):\n        if not self.approver.has_perm('work_order_management.approve_workorder'):\n            raise PermissionDenied('No approval permission')\n    \n    def _perform_approval(self, order):\n        order.status = 'APPROVED'\n        order.approved_by = self.approver\n        order.approved_at = timezone.now()\n        order.save()\n    \n    def _send_notifications(self, order):\n        from apps.work_order_management.tasks import send_approval_notifications\n        send_approval_notifications.delay(order.id)\n\n# In views.py (now 89 lines)\nfrom apps.work_order_management.services.approval_service import WorkOrderApprovalService\n\ndef approve_work_order(request, order_id):\n    order = WorkOrder.objects.get(id=order_id, tenant=request.tenant)\n    \n    service = WorkOrderApprovalService(approver=request.user)\n    order = service.approve(order)\n    \n    return JsonResponse({'status': 'approved', 'order_id': order.id})\n```\n\n### Pattern 4: Split Utils by Domain\n\n**Before** - utils.py (1,247 lines):\n```python\n# apps/core/utils.py (GOD FILE)\n\ndef format_date(dt):\n    # ...\n\ndef format_time(dt):\n    # ...\n\ndef send_email(to, subject, body):\n    # ...\n\ndef send_sms(to, message):\n    # ...\n\ndef validate_gps(lat, lon):\n    # ...\n\ndef calculate_distance(point1, point2):\n    # ...\n\ndef encrypt_data(data):\n    # ...\n\ndef hash_password(password):\n    # ...\n\n# ... 1000 more lines\n```\n\n**After** - utils_new/ (modular):\n```\nutils_new/\nâ”œâ”€â”€ __init__.py\nâ”œâ”€â”€ datetime_utilities.py    # Date/time functions\nâ”œâ”€â”€ notification_utilities.py # Email/SMS\nâ”œâ”€â”€ gps_utilities.py         # GPS/location\nâ”œâ”€â”€ security_utilities.py    # Encryption/hashing\nâ”œâ”€â”€ string_utilities.py      # String manipulation\nâ””â”€â”€ validation_utilities.py  # Input validation\n```\n\n### Pattern 5: Extract Forms by Purpose\n\n**Before** - forms.py (534 lines):\n```python\n# All forms in one file\nclass WorkOrderCreateForm(forms.ModelForm):\n    # ... 80 lines\n\nclass WorkOrderUpdateForm(forms.ModelForm):\n    # ... 75 lines\n\nclass WorkOrderApprovalForm(forms.Form):\n    # ... 60 lines\n\n# ... 10 more forms\n```\n\n**After** - forms/ (modular):\n```\nforms/\nâ”œâ”€â”€ __init__.py\nâ”œâ”€â”€ work_order_forms.py      # CRUD forms\nâ”œâ”€â”€ approval_forms.py        # Approval workflow\nâ”œâ”€â”€ assignment_forms.py      # Assignment logic\nâ””â”€â”€ filter_forms.py          # Search/filter\n```\n\n## Step-by-Step Refactoring Guide\n\n### Step 1: Identify God Files\n\n```bash\n# Find oversized files\npython scripts/check_file_sizes.py --verbose\n\n# Detect god files\npython scripts/detect_god_files.py --path apps/\n```\n\nOutput:\n```\nðŸ” God File Detection\n=====================\nFile: apps/activity/models.py (847 lines) âŒ\n  â†’ Split into 6 models\n  â†’ Suggested: models/ package\n\nFile: apps/peoples/views.py (532 lines) âŒ\n  â†’ Extract services\n  â†’ Suggested: services/ package\n```\n\n### Step 2: Analyze Dependencies\n\n```bash\n# Check what imports this file\npython scripts/analyze_imports.py apps/activity/models.py\n```\n\n### Step 3: Create Package Structure\n\n```bash\nmkdir apps/activity/models\ntouch apps/activity/models/__init__.py\n```\n\n### Step 4: Split Files\n\nMove each class to its own file:\n\n```python\n# apps/activity/models/task.py\n\"\"\"Task model - extracted from god file (Phase 5).\"\"\"\n\nfrom django.db import models\nfrom apps.tenants.models import TenantAwareModel\nfrom apps.peoples.models import People\n\nclass Task(TenantAwareModel):\n    \"\"\"Task model (145 lines - under 150 limit).\"\"\"\n    # ... fields and methods\n```\n\n### Step 5: Update __init__.py\n\n```python\n# apps/activity/models/__init__.py\n\"\"\"Activity models - refactored from god file (Phase 5).\"\"\"\n\nfrom .task import Task\nfrom .job import Job\nfrom .assignment import TaskAssignment\nfrom .location import TaskLocation\nfrom .comment import TaskComment\nfrom .attachment import TaskAttachment\n\n__all__ = [\n    'Task',\n    'Job',\n    'TaskAssignment',\n    'TaskLocation',\n    'TaskComment',\n    'TaskAttachment',\n]\n```\n\n### Step 6: Update Imports Throughout Codebase\n\n**Automated migration:**\n```bash\n# Update imports automatically\npython scripts/update_imports.py \\\n    --old \"from apps.activity.models import Task\" \\\n    --new \"from apps.activity.models import Task\"  # Same - package handles it\n\n# Verify no import errors\npython manage.py check\n```\n\n### Step 7: Run Tests\n\n```bash\n# Verify refactoring didn't break anything\npython -m pytest apps/activity/tests/ -v\n\n# Check for circular imports\npython scripts/detect_circular_deps.py --app activity\n```\n\n### Step 8: Validate File Sizes\n\n```bash\n# Ensure all files under limits\npython scripts/check_file_sizes.py --app activity\n```\n\nOutput:\n```\nâœ… All files pass size limits:\n  apps/activity/models/task.py: 145 lines (limit: 150)\n  apps/activity/models/job.py: 132 lines (limit: 150)\n  ...\n```\n\n## Real-World Results (Phase 1-6)\n\n### Attendance App Refactoring\n\n**Before:**\n- models.py: 847 lines âŒ\n- views.py: 634 lines âŒ\n- forms.py: 423 lines âŒ\n\n**After:**\n- models/: 6 files, avg 140 lines âœ…\n- views/: 4 files, avg 95 lines âœ…\n- forms/: 3 files, avg 98 lines âœ…\n\n### Work Order App Refactoring\n\n**Before:**\n- models.py: 1,124 lines âŒ\n- managers.py: 547 lines âŒ\n\n**After:**\n- models/: 8 files, avg 135 lines âœ…\n- managers/: 5 files, avg 95 lines âœ…\n\n## Backward Compatibility\n\nAll refactorings maintained **100% backward compatibility**:\n\n```python\n# Old imports still work\nfrom apps.activity.models import Task  # âœ… Works\n\n# New imports also work\nfrom apps.activity.models.task import Task  # âœ… Works\n```\n\n## Automated Tools\n\nWe provide comprehensive tooling:\n\n```bash\n# Detection\npython scripts/detect_god_files.py\npython scripts/check_file_sizes.py\n\n# Migration\npython scripts/refactor_god_file.py --file apps/activity/models.py\n\n# Verification\npython scripts/verify_refactoring.py --app activity\npython manage.py check\npython -m pytest apps/activity/\n```\n\n## Checklist\n\n- [ ] Identify god files (>200/150/100 lines)\n- [ ] Analyze dependencies and imports\n- [ ] Create package structure (models/, services/, etc.)\n- [ ] Split files by single responsibility\n- [ ] Update __init__.py with imports\n- [ ] Run automated import updates\n- [ ] Verify tests pass\n- [ ] Check for circular dependencies\n- [ ] Validate file sizes\n- [ ] Update documentation\n\n## Documentation\n\n- [Refactoring Playbook](file:///docs/architecture/REFACTORING_PLAYBOOK.md)\n- [Refactoring Patterns](file:///docs/architecture/REFACTORING_PATTERNS.md)\n- [Phase 1-6 Complete](file:///PHASES_2_6_IMPLEMENTATION_COMPLETE.md)\n- [God File Refactoring Guide](file:///ULTRATHINK_GOD_FILE_REFACTORING_GUIDE.md)\n- [Project Retrospective](file:///docs/PROJECT_RETROSPECTIVE.md)",
      "category_id": 202,
      "difficulty_level": "ADVANCED",
      "target_roles": ["developer", "tech_lead", "architect"],
      "status": "PUBLISHED",
      "version": 1,
      "view_count": 0,
      "helpful_count": 0,
      "not_helpful_count": 0,
      "published_date": "2025-11-06T00:00:00Z",
      "last_reviewed_date": "2025-11-06T00:00:00Z"
    }
  }
]
