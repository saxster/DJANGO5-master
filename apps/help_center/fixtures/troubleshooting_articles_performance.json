[
  {
    "model": "help_center.helparticle",
    "pk": 2101,
    "fields": {
      "tenant_id": 1,
      "title": "How to Identify N+1 Query Problems",
      "slug": "identify-n-plus-one-queries",
      "summary": "Use Django Debug Toolbar, query logging, and automated detection to find N+1 query problems that kill performance.",
      "content": "## What are N+1 Queries?\n\nN+1 queries occur when code executes:\n1. **1 query** to fetch a list of objects\n2. **N additional queries** (one per object) to fetch related data\n\nExample: Fetching 100 users â†’ 1 query for users + 100 queries for profiles = **101 total queries**\n\n## Detection Methods\n\n### Method 1: Django Debug Toolbar (Development)\n\n```bash\n# Install\npip install django-debug-toolbar\n```\n\n```python\n# settings/development.py\nINSTALLED_APPS += ['debug_toolbar']\nMIDDLEWARE += ['debug_toolbar.middleware.DebugToolbarMiddleware']\n\nINTERNAL_IPS = ['127.0.0.1']\n```\n\n```python\n# urls.py\nif settings.DEBUG:\n    import debug_toolbar\n    urlpatterns = [\n        path('__debug__/', include(debug_toolbar.urls)),\n    ] + urlpatterns\n```\n\nVisit any page and check the SQL panel - look for:\n- **High query counts** (>20 queries for simple pages)\n- **Similar queries** executed multiple times\n- **Duplicate queries** with different IDs\n\n### Method 2: Query Logging (Production)\n\n```python\n# settings/production.py\nLOGGING = {\n    'handlers': {\n        'query_file': {\n            'class': 'logging.FileHandler',\n            'filename': '/var/log/django/queries.log',\n        },\n    },\n    'loggers': {\n        'django.db.backends': {\n            'handlers': ['query_file'],\n            'level': 'DEBUG',\n            'propagate': False,\n        },\n    },\n}\n```\n\nAnalyze logs for patterns:\n```bash\ngrep \"SELECT.*FROM peoples_profile\" queries.log | wc -l\n```\n\n### Method 3: django-silk (Performance Profiling)\n\n```bash\npip install django-silk\n```\n\n```python\n# settings.py\nMIDDLEWARE += ['silk.middleware.SilkyMiddleware']\nINSTALLED_APPS += ['silk']\n```\n\nVisit `/silk/` to see:\n- Query timeline\n- Slow queries\n- N+1 detection\n\n### Method 4: Automated Detection\n\nUse our N+1 detection service:\n\n```python\nfrom apps.core.services.n1_query_detector import N1QueryDetector\nfrom django.test import TestCase\n\nclass PerformanceTests(TestCase):\n    def test_user_list_no_n1(self):\n        \"\"\"User list page should not have N+1 queries.\"\"\"\n        # Create test data\n        for i in range(10):\n            People.objects.create(username=f'user{i}')\n        \n        with N1QueryDetector() as detector:\n            response = self.client.get('/people/')\n        \n        # Assert query count is reasonable\n        self.assertLess(\n            detector.query_count,\n            5,\n            f'N+1 detected: {detector.query_count} queries'\n        )\n```\n\n## Common N+1 Patterns\n\n### Pattern 1: Accessing Related Objects in Template\n\n```django\n<!-- âŒ CAUSES N+1 -->\n{% for user in users %}\n    <div>\n        {{ user.username }} - {{ user.profile.department }}\n        <!-- Each profile access = 1 query -->\n    </div>\n{% endfor %}\n```\n\n### Pattern 2: Serializer with Nested Data\n\n```python\n# âŒ CAUSES N+1\nclass UserSerializer(serializers.ModelSerializer):\n    department = serializers.CharField(source='profile.department')\n    \n    class Meta:\n        model = People\n        fields = ['username', 'department']\n\n# When serializing a list:\nusers = People.objects.all()  # 1 query\nUserSerializer(users, many=True).data  # +N queries for profiles\n```\n\n### Pattern 3: View Accessing Related Data\n\n```python\n# âŒ CAUSES N+1\ndef user_list(request):\n    users = People.objects.all()  # 1 query\n    \n    user_data = []\n    for user in users:\n        # Each iteration = 1 query for profile\n        user_data.append({\n            'username': user.username,\n            'department': user.profile.department\n        })\n    \n    return JsonResponse({'users': user_data})\n```\n\n## Visual Detection in Code\n\nLook for these patterns:\n\n```python\n# âŒ RED FLAG: Loop with attribute access\nfor item in Item.objects.all():\n    print(item.related_object.name)  # N+1!\n\n# âŒ RED FLAG: List comprehension with relations\ndata = [user.profile.department for user in users]  # N+1!\n\n# âŒ RED FLAG: Serializer without prefetch\nserializer = MySerializer(queryset, many=True)  # Check Meta.fields\n```\n\n## Automated Detection Script\n\nRun our N+1 detection tool:\n\n```bash\n# Scan entire codebase\npython scripts/detect_n1_queries.py\n\n# Scan specific app\npython scripts/detect_n1_queries.py --app work_order_management\n\n# Generate report\npython scripts/detect_n1_queries.py --output n1_report.json\n```\n\nOutput:\n```json\n{\n  \"issues\": [\n    {\n      \"file\": \"apps/peoples/views.py\",\n      \"line\": 45,\n      \"pattern\": \"for user in users: user.profile\",\n      \"severity\": \"high\",\n      \"suggestion\": \"Use select_related('profile')\"\n    }\n  ]\n}\n```\n\n## Performance Baselines\n\n### Acceptable Query Counts (per page type)\n\n- **List pages**: 1-5 queries\n- **Detail pages**: 1-3 queries  \n- **Dashboard**: 5-10 queries\n- **Complex reports**: 10-20 queries\n\n**Red flag**: >20 queries on any page\n\n### Performance Budgets\n\n```python\n# settings/base.py\nPERFORMANCE_BUDGETS = {\n    'MAX_QUERIES_PER_REQUEST': 20,\n    'MAX_QUERY_TIME_MS': 100,\n    'MAX_DUPLICATE_QUERIES': 3,\n}\n```\n\n## Real-World Examples from Our Codebase\n\n### Example 1: Work Order List (Fixed)\n\n**Before** (45 queries):\n```python\ndef work_order_list(request):\n    orders = WorkOrder.objects.all()  # 1 query\n    # Template accesses order.assigned_to.username (N queries)\n    # Template accesses order.location.name (N queries)\n    return render(request, 'orders.html', {'orders': orders})\n```\n\n**After** (2 queries):\n```python\ndef work_order_list(request):\n    orders = WorkOrder.objects.select_related(\n        'assigned_to',\n        'location'\n    ).all()  # 2 queries (with JOINs)\n    return render(request, 'orders.html', {'orders': orders})\n```\n\n### Example 2: User API (Fixed)\n\n**Before** (101 queries for 100 users):\n```python\nclass UserViewSet(viewsets.ModelViewSet):\n    queryset = People.objects.all()\n    serializer_class = UserSerializer\n```\n\n**After** (3 queries):\n```python\nclass UserViewSet(viewsets.ModelViewSet):\n    queryset = People.objects.with_full_details()  # Custom manager\n    serializer_class = UserSerializer\n\n# In models/people.py\nclass PeopleManager(models.Manager):\n    def with_full_details(self):\n        return self.select_related(\n            'profile',\n            'organizational'\n        ).prefetch_related(\n            'user_permissions',\n            'groups'\n        )\n```\n\n## Query Count Assertion in Tests\n\n```python\nfrom django.test import TestCase\nfrom django.test.utils import override_settings\n\nclass PerformanceTests(TestCase):\n    def test_user_list_query_count(self):\n        \"\"\"User list should use <5 queries regardless of data size.\"\"\"\n        # Create 50 users\n        for i in range(50):\n            People.objects.create(username=f'user{i}')\n        \n        with self.assertNumQueries(4):  # Strict query count\n            response = self.client.get('/api/users/')\n            self.assertEqual(response.status_code, 200)\n```\n\n## Documentation\n\n- [N+1 Query Optimization Guide](file:///docs/architecture/QUERY_OPTIMIZATION_ARCHITECTURE.md)\n- [N+1 Detection Service](file:///apps/core/services/n1_query_detector.py)\n- [Complete N+1 Fixes](file:///N_PLUS_ONE_FIXES_PART1_COMPLETE.md)\n- [Django Query Optimization](https://docs.djangoproject.com/en/5.2/topics/db/optimization/)",
      "category_id": 201,
      "difficulty_level": "INTERMEDIATE",
      "target_roles": ["developer", "tech_lead"],
      "status": "PUBLISHED",
      "version": 1,
      "view_count": 0,
      "helpful_count": 0,
      "not_helpful_count": 0,
      "published_date": "2025-11-06T00:00:00Z",
      "last_reviewed_date": "2025-11-06T00:00:00Z"
    }
  },
  {
    "model": "help_center.helparticle",
    "pk": 2102,
    "fields": {
      "tenant_id": 1,
      "title": "How to Fix N+1 Queries with select_related",
      "slug": "fix-n1-select-related",
      "summary": "Use select_related() for ForeignKey and OneToOne relationships to eliminate N+1 queries with SQL JOINs.",
      "content": "## What is select_related?\n\n`select_related()` performs a SQL JOIN and includes related object data in a single query. Use it for:\n- **ForeignKey** relationships (many-to-one)\n- **OneToOneField** relationships\n\n## Basic Usage\n\n### âŒ Without select_related (N+1 Problem)\n\n```python\n# 1 query to get users\nusers = People.objects.all()\n\n# Loop causes N additional queries\nfor user in users:\n    print(user.profile.department)  # 1 query per user\n    print(user.organizational.site)  # 1 more query per user\n\n# Total: 1 + N + N = 1 + 2N queries (201 queries for 100 users!)\n```\n\n### âœ… With select_related (2 Queries)\n\n```python\n# Single query with JOINs\nusers = People.objects.select_related('profile', 'organizational').all()\n\n# No additional queries!\nfor user in users:\n    print(user.profile.department)  # Already loaded\n    print(user.organizational.site)  # Already loaded\n\n# Total: 1 query (or 2-3 with complex JOINs)\n```\n\n## SQL Comparison\n\n### Without select_related\n\n```sql\n-- Query 1: Get users\nSELECT * FROM peoples_people;\n\n-- Query 2: Get profile for user 1\nSELECT * FROM peoples_peopleprofile WHERE people_id = 1;\n\n-- Query 3: Get profile for user 2\nSELECT * FROM peoples_peopleprofile WHERE people_id = 2;\n\n-- ... (N more queries)\n```\n\n### With select_related\n\n```sql\n-- Single query with JOINs\nSELECT \n    people.*,\n    profile.*,\n    org.*\nFROM peoples_people people\nLEFT JOIN peoples_peopleprofile profile ON people.id = profile.people_id\nLEFT JOIN peoples_peopleorganizational org ON people.id = org.people_id;\n```\n\n## Common Patterns\n\n### Pattern 1: Views\n\n```python\nfrom django.shortcuts import render\nfrom apps.work_order_management.models import WorkOrder\n\ndef work_order_list(request):\n    # âœ… CORRECT\n    orders = WorkOrder.objects.select_related(\n        'assigned_to',           # ForeignKey to People\n        'location',              # ForeignKey to Location\n        'created_by',            # ForeignKey to People\n        'assigned_to__profile',  # Nested: get assigned user's profile\n    ).filter(tenant=request.tenant)\n    \n    return render(request, 'work_orders.html', {'orders': orders})\n```\n\n### Pattern 2: Django REST Framework Serializers\n\n```python\nfrom rest_framework import viewsets\nfrom apps.peoples.models import People\n\nclass UserViewSet(viewsets.ModelViewSet):\n    # âœ… CORRECT\n    queryset = People.objects.select_related(\n        'profile',\n        'organizational'\n    ).all()\n    \n    serializer_class = UserSerializer\n```\n\n### Pattern 3: Custom Model Managers\n\n```python\nfrom django.db import models\n\nclass PeopleManager(models.Manager):\n    def with_profile(self):\n        \"\"\"Get people with profile data pre-loaded.\"\"\"\n        return self.select_related('profile')\n    \n    def with_full_details(self):\n        \"\"\"Get people with all related data.\"\"\"\n        return self.select_related(\n            'profile',\n            'organizational',\n            'created_by',\n            'updated_by'\n        )\n\nclass People(models.Model):\n    objects = PeopleManager()\n    # ... fields ...\n\n# Usage\nusers = People.objects.with_full_details()\n```\n\n## Nested Relationships (Follow ForeignKeys)\n\n```python\nfrom apps.work_order_management.models import WorkOrder\n\n# âœ… Follow relationships with __\norders = WorkOrder.objects.select_related(\n    'assigned_to',                    # WorkOrder â†’ People\n    'assigned_to__profile',           # People â†’ PeopleProfile\n    'assigned_to__organizational',    # People â†’ PeopleOrganizational\n    'location',                       # WorkOrder â†’ Location\n    'location__site',                 # Location â†’ Site\n    'location__site__client'          # Site â†’ Client\n).all()\n\n# Now you can access nested data without queries\nfor order in orders:\n    print(order.assigned_to.profile.department)\n    print(order.location.site.client.name)\n```\n\n## Conditional select_related\n\n```python\ndef get_work_orders(request, include_location=False):\n    queryset = WorkOrder.objects.select_related('assigned_to')\n    \n    if include_location:\n        queryset = queryset.select_related('location', 'location__site')\n    \n    return queryset.filter(tenant=request.tenant)\n```\n\n## Combining with Filtering\n\n```python\n# âœ… CORRECT: select_related works with filters\nactive_orders = WorkOrder.objects.select_related(\n    'assigned_to',\n    'location'\n).filter(\n    status='ACTIVE',\n    tenant=request.tenant\n).order_by('-created_at')\n```\n\n## When NOT to Use select_related\n\n### âŒ Don't use for ManyToManyField\n\n```python\n# âŒ WRONG: select_related doesn't work with M2M\nusers = People.objects.select_related('groups').all()  # Does nothing!\n\n# âœ… CORRECT: Use prefetch_related instead\nusers = People.objects.prefetch_related('groups').all()\n```\n\n### âŒ Don't use for Reverse ForeignKey\n\n```python\n# âŒ WRONG: Can't follow reverse relationships\nclients = Client.objects.select_related('sites').all()  # Error!\n# (Client has no 'sites' field, Site has 'client' field)\n\n# âœ… CORRECT: Use prefetch_related\nclients = Client.objects.prefetch_related('site_set').all()\n```\n\n## Performance Impact\n\n### Benchmark Results (100 records)\n\n| Method | Queries | Time |\n|--------|---------|------|\n| No optimization | 201 | 2.3s |\n| select_related('profile') | 101 | 1.2s |\n| select_related('profile', 'organizational') | 2 | 0.15s |\n\n**Speed improvement: 15x faster! ðŸš€**\n\n## Testing select_related\n\n```python\nfrom django.test import TestCase\n\nclass QueryOptimizationTests(TestCase):\n    def test_user_list_optimized(self):\n        \"\"\"User list should use select_related.\"\"\"\n        # Create test data\n        for i in range(10):\n            People.objects.create(username=f'user{i}')\n        \n        # Should use â‰¤3 queries\n        with self.assertNumQueries(3):\n            users = list(\n                People.objects.select_related('profile', 'organizational').all()\n            )\n            # Access related data (should not trigger queries)\n            for user in users:\n                _ = user.profile.department\n                _ = user.organizational.site\n```\n\n## Migration Guide\n\n### Step 1: Find N+1 Issues\n\n```bash\n# Run detection\npython scripts/detect_n1_queries.py --app peoples\n```\n\n### Step 2: Update Querysets\n\n```python\n# Before\nusers = People.objects.all()\n\n# After\nusers = People.objects.select_related('profile', 'organizational').all()\n```\n\n### Step 3: Update Tests\n\n```python\n# Add query count assertions\nwith self.assertNumQueries(2):\n    response = self.client.get('/api/users/')\n```\n\n### Step 4: Verify Performance\n\n```bash\n# Run validation\npython scripts/validate_n1_optimization.py\n```\n\n## Real-World Examples\n\n### Example 1: Work Order List View\n\n```python\n# apps/work_order_management/views.py\nfrom django.views.generic import ListView\n\nclass WorkOrderListView(ListView):\n    model = WorkOrder\n    \n    def get_queryset(self):\n        return WorkOrder.objects.select_related(\n            'assigned_to',\n            'assigned_to__profile',\n            'location',\n            'created_by',\n            'approved_by'\n        ).filter(tenant=self.request.tenant)\n```\n\n### Example 2: API Endpoint\n\n```python\n# apps/peoples/views.py\nfrom rest_framework.decorators import api_view\n\n@api_view(['GET'])\ndef user_detail(request, user_id):\n    user = People.objects.select_related(\n        'profile',\n        'organizational',\n        'organizational__site',\n        'organizational__site__client'\n    ).get(id=user_id, tenant=request.tenant)\n    \n    return Response({\n        'username': user.username,\n        'department': user.profile.department,\n        'site': user.organizational.site.name,\n        'client': user.organizational.site.client.name\n    })\n```\n\n### Example 3: Template Context\n\n```python\n# apps/activity/views.py\ndef task_list(request):\n    tasks = Task.objects.select_related(\n        'assigned_people',\n        'assigned_people__profile',\n        'job',\n        'job__client'\n    ).filter(\n        tenant=request.tenant,\n        status='ACTIVE'\n    )\n    \n    return render(request, 'tasks.html', {'tasks': tasks})\n```\n\n## Quick Reference\n\n```python\n# Single relationship\nModel.objects.select_related('foreign_key_field')\n\n# Multiple relationships\nModel.objects.select_related('field1', 'field2', 'field3')\n\n# Nested relationships\nModel.objects.select_related('field__nested_field')\n\n# With filtering\nModel.objects.select_related('field').filter(status='ACTIVE')\n\n# In custom manager\nclass MyManager(models.Manager):\n    def optimized(self):\n        return self.select_related('field1', 'field2')\n```\n\n## Checklist\n\n- [ ] Identify ForeignKey/OneToOne relationships accessed in loops\n- [ ] Add select_related() to queryset\n- [ ] Include nested relationships with `__`\n- [ ] Write tests with query count assertions\n- [ ] Verify performance improvement\n- [ ] Update custom managers\n\n## Documentation\n\n- [Query Optimization Architecture](file:///docs/architecture/QUERY_OPTIMIZATION_ARCHITECTURE.md)\n- [N+1 Fixes Part 1](file:///N_PLUS_ONE_FIXES_PART1_COMPLETE.md)\n- [Django select_related Docs](https://docs.djangoproject.com/en/5.2/ref/models/querysets/#select-related)",
      "category_id": 201,
      "difficulty_level": "BEGINNER",
      "target_roles": ["developer"],
      "status": "PUBLISHED",
      "version": 1,
      "view_count": 0,
      "helpful_count": 0,
      "not_helpful_count": 0,
      "published_date": "2025-11-06T00:00:00Z",
      "last_reviewed_date": "2025-11-06T00:00:00Z"
    }
  },
  {
    "model": "help_center.helparticle",
    "pk": 2103,
    "fields": {
      "tenant_id": 1,
      "title": "How to Fix N+1 Queries with prefetch_related",
      "slug": "fix-n1-prefetch-related",
      "summary": "Use prefetch_related() for ManyToMany and reverse ForeignKey relationships to eliminate N+1 queries with separate optimized queries.",
      "content": "## What is prefetch_related?\n\n`prefetch_related()` performs separate queries for related objects and joins them in Python. Use it for:\n- **ManyToManyField** relationships\n- **Reverse ForeignKey** relationships (e.g., `client.sites.all()`)\n- **GenericForeignKey** relationships\n\n## Difference from select_related\n\n| Feature | select_related | prefetch_related |\n|---------|----------------|------------------|\n| Works with | ForeignKey, OneToOne | ManyToMany, Reverse FK |\n| SQL Strategy | Single query with JOIN | Multiple optimized queries |\n| Memory | Lower (single query) | Higher (stores in Python) |\n| Use case | Direct relationships | Collections |\n\n## Basic Usage\n\n### âŒ Without prefetch_related (N+1 Problem)\n\n```python\n# 1 query to get users\nusers = People.objects.all()\n\n# Loop causes N queries\nfor user in users:\n    # 1 query per user to get groups\n    groups = user.groups.all()\n    print(list(groups))\n\n# Total: 1 + N queries (101 queries for 100 users!)\n```\n\n### âœ… With prefetch_related (2 Queries)\n\n```python\n# 2 queries total\nusers = People.objects.prefetch_related('groups').all()\n\n# No additional queries!\nfor user in users:\n    groups = user.groups.all()  # Already prefetched\n    print(list(groups))\n\n# Total: 2 queries (users + groups)\n```\n\n## SQL Behavior\n\n### Query 1: Main Objects\n```sql\nSELECT * FROM peoples_people;\n-- Returns IDs: [1, 2, 3, 4, 5]\n```\n\n### Query 2: Related Objects (Optimized)\n```sql\nSELECT * FROM auth_group \nINNER JOIN peoples_people_groups \n  ON auth_group.id = peoples_people_groups.group_id\nWHERE peoples_people_groups.people_id IN (1, 2, 3, 4, 5);\n-- Single query for ALL related groups\n```\n\nDjango then joins the results in Python memory.\n\n## Common Patterns\n\n### Pattern 1: ManyToManyField\n\n```python\nfrom apps.peoples.models import People\n\n# âœ… Prefetch user permissions and groups\nusers = People.objects.prefetch_related(\n    'groups',\n    'user_permissions'\n).all()\n\nfor user in users:\n    print(f\"User: {user.username}\")\n    print(f\"Groups: {list(user.groups.values_list('name', flat=True))}\")\n    print(f\"Perms: {list(user.user_permissions.all())}\")\n```\n\n### Pattern 2: Reverse ForeignKey\n\n```python\nfrom apps.tenants.models import Client\n\n# Client â†’ Site (reverse FK: site.client)\n# âœ… Prefetch all sites for each client\nclients = Client.objects.prefetch_related('site_set').all()\n\nfor client in clients:\n    # No additional queries\n    sites = client.site_set.all()\n    print(f\"{client.name}: {sites.count()} sites\")\n```\n\n### Pattern 3: Nested Prefetching\n\n```python\nfrom django.db.models import Prefetch\nfrom apps.work_order_management.models import WorkOrder\n\n# Prefetch work orders AND their assigned users' profiles\nclients = Client.objects.prefetch_related(\n    'site_set',                           # Client â†’ Sites\n    'site_set__workorder_set',           # Sites â†’ Work Orders\n    'site_set__workorder_set__assigned_to',  # Work Orders â†’ Users\n    'site_set__workorder_set__assigned_to__profile'  # Users â†’ Profiles\n).all()\n\nfor client in clients:\n    for site in client.site_set.all():\n        for order in site.workorder_set.all():\n            print(f\"{order.title} assigned to {order.assigned_to.profile.full_name}\")\n```\n\n## Advanced: Custom Prefetch with Filters\n\n### Basic Prefetch (all related objects)\n\n```python\nclients = Client.objects.prefetch_related('site_set').all()\n# Prefetches ALL sites\n```\n\n### Custom Prefetch (filtered)\n\n```python\nfrom django.db.models import Prefetch\nfrom apps.tenants.models import Site\n\n# Only prefetch ACTIVE sites\nactive_sites = Site.objects.filter(is_active=True)\n\nclients = Client.objects.prefetch_related(\n    Prefetch('site_set', queryset=active_sites, to_attr='active_sites')\n).all()\n\nfor client in clients:\n    # Access via custom attribute\n    for site in client.active_sites:  # Only active sites\n        print(site.name)\n```\n\n### Complex Prefetch Example\n\n```python\nfrom django.db.models import Prefetch\nfrom apps.work_order_management.models import WorkOrder\n\n# Prefetch only PENDING work orders with assigned users\npending_orders = WorkOrder.objects.filter(\n    status='PENDING'\n).select_related('assigned_to', 'assigned_to__profile')\n\nclients = Client.objects.prefetch_related(\n    Prefetch(\n        'site_set__workorder_set',\n        queryset=pending_orders,\n        to_attr='pending_orders'\n    )\n).all()\n\nfor client in clients:\n    for site in client.site_set.all():\n        # Access filtered work orders\n        for order in site.pending_orders:\n            print(f\"{order.title} - {order.assigned_to.username}\")\n```\n\n## Combining select_related and prefetch_related\n\n```python\n# âœ… OPTIMAL: Use both together\nusers = People.objects.select_related(\n    'profile',           # ForeignKey â†’ use select_related\n    'organizational'     # ForeignKey â†’ use select_related\n).prefetch_related(\n    'groups',            # ManyToMany â†’ use prefetch_related\n    'user_permissions'   # ManyToMany â†’ use prefetch_related\n).all()\n\nfor user in users:\n    # All accessed without queries\n    print(user.profile.department)      # select_related\n    print(user.organizational.site)     # select_related\n    print(list(user.groups.all()))      # prefetch_related\n    print(list(user.user_permissions.all()))  # prefetch_related\n```\n\n## Performance Comparison\n\n### Benchmark (100 users, 5 groups each)\n\n| Method | Queries | Time |\n|--------|---------|------|\n| No optimization | 101 | 1.8s |\n| prefetch_related('groups') | 2 | 0.12s |\n| + select_related('profile') | 2 | 0.10s |\n\n**Speed improvement: 18x faster! ðŸš€**\n\n## Custom Model Managers\n\n```python\nfrom django.db import models\n\nclass PeopleManager(models.Manager):\n    def with_permissions(self):\n        \"\"\"Prefetch groups and permissions.\"\"\"\n        return self.prefetch_related(\n            'groups',\n            'user_permissions'\n        )\n    \n    def with_full_details(self):\n        \"\"\"Optimized queryset with all related data.\"\"\"\n        return self.select_related(\n            'profile',\n            'organizational'\n        ).prefetch_related(\n            'groups',\n            'user_permissions',\n            'created_tasks',\n            'assigned_tasks'\n        )\n\nclass People(models.Model):\n    objects = PeopleManager()\n    # ... fields ...\n\n# Usage\nusers = People.objects.with_full_details()\n```\n\n## Django REST Framework Optimization\n\n```python\nfrom rest_framework import viewsets\nfrom apps.peoples.models import People\nfrom apps.peoples.serializers import UserDetailSerializer\n\nclass UserViewSet(viewsets.ModelViewSet):\n    serializer_class = UserDetailSerializer\n    \n    def get_queryset(self):\n        return People.objects.select_related(\n            'profile',\n            'organizational'\n        ).prefetch_related(\n            'groups',\n            'user_permissions',\n            Prefetch(\n                'assigned_tasks',\n                queryset=Task.objects.filter(status='ACTIVE'),\n                to_attr='active_tasks'\n            )\n        )\n```\n\n## Common Pitfalls\n\n### âŒ Pitfall 1: Filtering After Prefetch\n\n```python\n# âŒ WRONG: Filtering after prefetch negates optimization\nusers = People.objects.prefetch_related('groups').all()\n\nfor user in users:\n    # This triggers a new query!\n    admin_groups = user.groups.filter(name__contains='admin')\n```\n\n```python\n# âœ… CORRECT: Use custom Prefetch\nfrom django.db.models import Prefetch\n\nadmin_groups = Group.objects.filter(name__contains='admin')\n\nusers = People.objects.prefetch_related(\n    Prefetch('groups', queryset=admin_groups, to_attr='admin_groups')\n).all()\n\nfor user in users:\n    # No query - uses prefetched data\n    for group in user.admin_groups:\n        print(group.name)\n```\n\n### âŒ Pitfall 2: Using select_related for M2M\n\n```python\n# âŒ WRONG: select_related doesn't work with ManyToMany\nusers = People.objects.select_related('groups').all()  # Does nothing!\n\n# âœ… CORRECT: Use prefetch_related\nusers = People.objects.prefetch_related('groups').all()\n```\n\n### âŒ Pitfall 3: Not Prefetching Nested Relations\n\n```python\n# âŒ INCOMPLETE: Prefetches tasks but not their related data\nusers = People.objects.prefetch_related('assigned_tasks').all()\n\nfor user in users:\n    for task in user.assigned_tasks.all():\n        print(task.job.client.name)  # N+1 on tasks!\n\n# âœ… CORRECT: Prefetch nested relations\nusers = People.objects.prefetch_related(\n    'assigned_tasks',\n    'assigned_tasks__job',\n    'assigned_tasks__job__client'\n).all()\n```\n\n## Testing prefetch_related\n\n```python\nfrom django.test import TestCase\n\nclass PrefetchTests(TestCase):\n    def test_user_groups_prefetched(self):\n        \"\"\"User groups should be prefetched.\"\"\"\n        # Create test data\n        group1 = Group.objects.create(name='Managers')\n        group2 = Group.objects.create(name='Employees')\n        \n        for i in range(10):\n            user = People.objects.create(username=f'user{i}')\n            user.groups.add(group1, group2)\n        \n        # Should use only 2 queries (users + groups)\n        with self.assertNumQueries(2):\n            users = list(\n                People.objects.prefetch_related('groups').all()\n            )\n            # Access groups (should not trigger queries)\n            for user in users:\n                _ = list(user.groups.all())\n```\n\n## Real-World Examples\n\n### Example 1: Client Sites Dashboard\n\n```python\n# apps/tenants/views.py\ndef client_dashboard(request, client_id):\n    from django.db.models import Prefetch\n    from apps.tenants.models import Client, Site\n    from apps.work_order_management.models import WorkOrder\n    \n    # Prefetch active sites with pending work orders\n    active_sites = Site.objects.filter(is_active=True)\n    pending_orders = WorkOrder.objects.filter(\n        status='PENDING'\n    ).select_related('assigned_to')\n    \n    client = Client.objects.prefetch_related(\n        Prefetch('site_set', queryset=active_sites, to_attr='active_sites'),\n        Prefetch('site_set__workorder_set', queryset=pending_orders, to_attr='pending_orders')\n    ).get(id=client_id)\n    \n    return render(request, 'client_dashboard.html', {'client': client})\n```\n\n### Example 2: User Permissions API\n\n```python\n# apps/peoples/views.py\nfrom rest_framework.decorators import api_view\n\n@api_view(['GET'])\ndef user_permissions(request, user_id):\n    user = People.objects.prefetch_related(\n        'groups',\n        'groups__permissions',\n        'user_permissions'\n    ).get(id=user_id)\n    \n    # All permissions (from groups + direct)\n    all_perms = set()\n    \n    # Group permissions (no queries)\n    for group in user.groups.all():\n        all_perms.update(group.permissions.values_list('codename', flat=True))\n    \n    # Direct permissions (no queries)\n    all_perms.update(user.user_permissions.values_list('codename', flat=True))\n    \n    return Response({'permissions': list(all_perms)})\n```\n\n## Migration Guide\n\n### Step 1: Identify Reverse/M2M Access\n\n```bash\n# Find potential N+1 with reverse relationships\ngrep -r \"\\.all()\" apps/ | grep -E \"for .* in\"\ngrep -r \"_set\\.\" apps/\n```\n\n### Step 2: Add prefetch_related\n\n```python\n# Before\nclients = Client.objects.all()\n\n# After\nclients = Client.objects.prefetch_related('site_set').all()\n```\n\n### Step 3: Test Query Count\n\n```python\nwith self.assertNumQueries(2):\n    clients = list(Client.objects.prefetch_related('site_set').all())\n    for client in clients:\n        _ = list(client.site_set.all())\n```\n\n## Quick Reference\n\n```python\n# Basic M2M prefetch\nModel.objects.prefetch_related('many_to_many_field')\n\n# Reverse FK prefetch\nModel.objects.prefetch_related('related_name_set')\n\n# Multiple prefetches\nModel.objects.prefetch_related('field1', 'field2', 'field3')\n\n# Nested prefetch\nModel.objects.prefetch_related('field__nested_field')\n\n# Custom filtered prefetch\nfrom django.db.models import Prefetch\nModel.objects.prefetch_related(\n    Prefetch('field', queryset=CustomQueryset, to_attr='custom_name')\n)\n\n# Combining with select_related\nModel.objects.select_related('fk_field').prefetch_related('m2m_field')\n```\n\n## Checklist\n\n- [ ] Identify ManyToMany and reverse FK access in loops\n- [ ] Add prefetch_related() to queryset\n- [ ] Use Prefetch() for filtered related objects\n- [ ] Combine with select_related() where applicable\n- [ ] Write tests with query count assertions\n- [ ] Verify performance improvement\n\n## Documentation\n\n- [Query Optimization Architecture](file:///docs/architecture/QUERY_OPTIMIZATION_ARCHITECTURE.md)\n- [N+1 Optimization Part 2](file:///N1_OPTIMIZATION_PART2_DELIVERABLES.md)\n- [Django prefetch_related Docs](https://docs.djangoproject.com/en/5.2/ref/models/querysets/#prefetch-related)",
      "category_id": 201,
      "difficulty_level": "INTERMEDIATE",
      "target_roles": ["developer", "tech_lead"],
      "status": "PUBLISHED",
      "version": 1,
      "view_count": 0,
      "helpful_count": 0,
      "not_helpful_count": 0,
      "published_date": "2025-11-06T00:00:00Z",
      "last_reviewed_date": "2025-11-06T00:00:00Z"
    }
  }
]
