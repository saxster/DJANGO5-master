[
  {
    "model": "help_center.helparticle",
    "pk": 2001,
    "fields": {
      "tenant_id": 1,
      "title": "How to Fix IDOR Vulnerabilities",
      "slug": "fix-idor-vulnerabilities",
      "summary": "Step-by-step guide to identifying and fixing Insecure Direct Object Reference (IDOR) vulnerabilities that allow unauthorized access to resources.",
      "content": "## Understanding IDOR Vulnerabilities\n\nIDOR (Insecure Direct Object Reference) vulnerabilities occur when an application exposes direct references to internal objects (like database records) without proper authorization checks. Attackers can manipulate these references to access unauthorized data.\n\n## Common IDOR Patterns\n\n### ❌ VULNERABLE: No Permission Check\n\n```python\ndef view_work_order(request, order_id):\n    # IDOR VULNERABILITY: Any authenticated user can view any work order\n    order = WorkOrder.objects.get(id=order_id)\n    return render(request, 'work_order.html', {'order': order})\n```\n\n### ✅ SECURE: Multi-Layer Validation\n\n```python\ndef view_work_order(request, order_id):\n    # 1. Tenant isolation\n    order = WorkOrder.objects.filter(\n        tenant=request.tenant,\n        id=order_id\n    ).first()\n    \n    if not order:\n        raise Http404('Work order not found')\n    \n    # 2. Permission check\n    if not request.user.has_perm('work_order_management.view_workorder', order):\n        raise PermissionDenied('You do not have permission to view this work order')\n    \n    # 3. Ownership/role validation\n    if not (\n        order.assigned_to == request.user or\n        order.created_by == request.user or\n        request.user.has_role(['manager', 'supervisor'])\n    ):\n        raise PermissionDenied('This work order is not assigned to you')\n    \n    return render(request, 'work_order.html', {'order': order})\n```\n\n## Testing for IDOR\n\nAlways write tests that verify authorization:\n\n```python\ndef test_cannot_view_other_user_work_order(self):\n    \"\"\"User A cannot access User B's work order.\"\"\"\n    user_a = create_user('alice')\n    user_b = create_user('bob')\n    \n    order = WorkOrder.objects.create(\n        assigned_to=user_b,\n        tenant=user_a.tenant\n    )\n    \n    self.client.force_login(user_a)\n    response = self.client.get(f'/work-orders/{order.id}/')\n    \n    assert response.status_code == 403  # Permission denied\n```\n\n## Automated IDOR Detection\n\nRun our security test suite:\n\n```bash\npython -m pytest tests/security/test_idor_vulnerabilities.py -v\n```\n\n## Common Vulnerable Endpoints\n\n1. **File Downloads** - Always validate file ownership\n2. **API Endpoints** - Check permissions before serializing\n3. **AJAX Calls** - Don't trust client-side filtering\n4. **Export Functions** - Validate data scope\n\n## Quick Remediation Checklist\n\n- [ ] Tenant isolation via queryset filtering\n- [ ] Django permission checks (`has_perm`)\n- [ ] Ownership validation (created_by, assigned_to)\n- [ ] Role-based access control\n- [ ] Security tests for cross-user access\n- [ ] Audit logging for sensitive operations\n\n## Documentation\n\n- [IDOR Security Tests](file:///tests/security/test_idor_vulnerabilities.py)\n- [Secure File Download Service](file:///apps/core/services/secure_file_download_service.py)\n- [Complete IDOR Audit Report](file:///IDOR_VULNERABILITY_AUDIT_REPORT.md)",
      "category_id": 200,
      "difficulty_level": "INTERMEDIATE",
      "target_roles": ["developer", "security", "tech_lead"],
      "status": "PUBLISHED",
      "version": 1,
      "view_count": 0,
      "helpful_count": 0,
      "not_helpful_count": 0,
      "published_date": "2025-11-06T00:00:00Z",
      "last_reviewed_date": "2025-11-06T00:00:00Z"
    }
  },
  {
    "model": "help_center.helparticle",
    "pk": 2002,
    "fields": {
      "tenant_id": 1,
      "title": "How to Add Rate Limiting to Endpoints",
      "slug": "add-rate-limiting",
      "summary": "Protect your API endpoints from abuse with rate limiting using Django decorators and middleware.",
      "content": "## Why Rate Limiting?\n\nRate limiting prevents:\n- **Brute force attacks** on authentication endpoints\n- **Denial of Service (DoS)** attacks\n- **API abuse** and resource exhaustion\n- **Credential stuffing** attacks\n\n## Implementation with django-ratelimit\n\n### Installation\n\n```bash\npip install django-ratelimit\n```\n\n### Function-Based Views\n\n```python\nfrom django_ratelimit.decorators import ratelimit\nfrom django.http import HttpResponse\n\n@ratelimit(key='ip', rate='5/m', method='POST')\ndef login_view(request):\n    if getattr(request, 'limited', False):\n        return HttpResponse('Rate limit exceeded. Try again in 1 minute.', status=429)\n    \n    # Normal login logic\n    return authenticate_user(request)\n```\n\n### Class-Based Views\n\n```python\nfrom django.utils.decorators import method_decorator\nfrom django.views import View\nfrom django_ratelimit.decorators import ratelimit\n\nclass SSOLoginView(View):\n    @method_decorator(ratelimit(key='ip', rate='10/h', method='POST'))\n    def post(self, request):\n        if getattr(request, 'limited', False):\n            return JsonResponse(\n                {'error': 'Too many login attempts'},\n                status=429\n            )\n        return self.process_sso_login(request)\n```\n\n### API Endpoints\n\n```python\nfrom rest_framework.decorators import api_view\nfrom django_ratelimit.decorators import ratelimit\n\n@api_view(['POST'])\n@ratelimit(key='user_or_ip', rate='100/h')\ndef password_reset_api(request):\n    if getattr(request, 'limited', False):\n        return Response(\n            {'detail': 'Rate limit exceeded'},\n            status=status.HTTP_429_TOO_MANY_REQUESTS\n        )\n    # Process password reset\n    return Response({'status': 'ok'})\n```\n\n## Rate Limit Keys\n\n- `'ip'` - Limit by IP address\n- `'user'` - Limit by authenticated user\n- `'user_or_ip'` - Limit by user if authenticated, else IP\n- Custom function for complex logic\n\n## Rate Formats\n\n- `'5/m'` - 5 requests per minute\n- `'10/h'` - 10 requests per hour\n- `'100/d'` - 100 requests per day\n- `'1000/s'` - 1000 requests per second\n\n## Global Middleware (Optional)\n\nAdd to `MIDDLEWARE` in settings:\n\n```python\nMIDDLEWARE = [\n    # ...\n    'django_ratelimit.middleware.RatelimitMiddleware',\n]\n\nRATELIMIT_ENABLE = True\nRATELIMIT_VIEW = 'myapp.views.rate_limit_exceeded'\n```\n\n## Testing Rate Limits\n\n```python\nfrom django.test import TestCase\nfrom unittest.mock import patch\n\nclass RateLimitTests(TestCase):\n    def test_login_rate_limit(self):\n        \"\"\"Verify rate limit blocks excessive login attempts.\"\"\"\n        for i in range(5):\n            response = self.client.post('/auth/login/', {\n                'username': 'test',\n                'password': 'wrong'\n            })\n            # First 5 should go through\n            self.assertIn(response.status_code, [200, 401])\n        \n        # 6th attempt should be blocked\n        response = self.client.post('/auth/login/', {\n            'username': 'test',\n            'password': 'wrong'\n        })\n        self.assertEqual(response.status_code, 429)\n```\n\n## Production Monitoring\n\nLog rate limit violations:\n\n```python\nimport logging\nlogger = logging.getLogger(__name__)\n\n@ratelimit(key='ip', rate='5/m', method='POST')\ndef sensitive_endpoint(request):\n    if getattr(request, 'limited', False):\n        logger.warning(\n            f'Rate limit exceeded: {request.META.get(\"REMOTE_ADDR\")} '\n            f'on {request.path}'\n        )\n        return HttpResponse('Rate limited', status=429)\n```\n\n## Critical Endpoints to Protect\n\n1. **Authentication** - `/auth/login/`, `/auth/sso/`\n2. **Password Reset** - `/auth/reset-password/`\n3. **File Uploads** - `/api/upload/`\n4. **Report Generation** - `/reports/generate/`\n5. **Data Exports** - `/api/export/`\n\n## Documentation\n\n- [SSO Rate Limiting Implementation](file:///SECURITY_FIX_4_SSO_RATE_LIMITING_COMPLETE.md)\n- [django-ratelimit Documentation](https://django-ratelimit.readthedocs.io/)",
      "category_id": 200,
      "difficulty_level": "BEGINNER",
      "target_roles": ["developer", "security"],
      "status": "PUBLISHED",
      "version": 1,
      "view_count": 0,
      "helpful_count": 0,
      "not_helpful_count": 0,
      "published_date": "2025-11-06T00:00:00Z",
      "last_reviewed_date": "2025-11-06T00:00:00Z"
    }
  },
  {
    "model": "help_center.helparticle",
    "pk": 2003,
    "fields": {
      "tenant_id": 1,
      "title": "How to Secure File Downloads",
      "slug": "secure-file-downloads",
      "summary": "Implement multi-layer security for file downloads to prevent path traversal, IDOR, and cross-tenant access.",
      "content": "## File Download Security Layers\n\nSecure file downloads require **five layers of protection**:\n\n1. **Tenant Isolation** - Block cross-tenant access\n2. **Ownership Validation** - Verify file ownership\n3. **Path Traversal Prevention** - Enforce MEDIA_ROOT boundaries\n4. **Permission Checks** - Role-based access control\n5. **Audit Logging** - Track all access attempts\n\n## Using SecureFileDownloadService\n\n### ❌ VULNERABLE: Direct File Access\n\n```python\ndef download_attachment(request, attachment_id):\n    # SECURITY ISSUES:\n    # 1. No tenant check\n    # 2. No ownership validation\n    # 3. No path traversal protection\n    attachment = Attachment.objects.get(id=attachment_id)\n    filepath = os.path.join(settings.MEDIA_ROOT, attachment.filepath)\n    return FileResponse(open(filepath, 'rb'))\n```\n\n### ✅ SECURE: Multi-Layer Validation\n\n```python\nfrom apps.core.services.secure_file_download_service import SecureFileDownloadService\nfrom django.http import Http404, JsonResponse\n\ndef download_attachment(request, attachment_id):\n    try:\n        # Layer 1 & 2: Validate attachment access (tenant + ownership)\n        attachment = SecureFileDownloadService.validate_attachment_access(\n            attachment_id=attachment_id,\n            user=request.user\n        )\n        \n        # Layer 3-5: Serve file with path validation + audit logging\n        return SecureFileDownloadService.validate_and_serve_file(\n            filepath=attachment.filepath,\n            filename=attachment.filename,\n            user=request.user,\n            owner_id=attachment.owner\n        )\n        \n    except Attachment.DoesNotExist:\n        raise Http404('Attachment not found')\n    except PermissionDenied as e:\n        return JsonResponse({'error': str(e)}, status=403)\n```\n\n## How It Works\n\n### Step 1: Attachment Validation\n\n```python\ndef validate_attachment_access(attachment_id, user):\n    \"\"\"Validate tenant isolation and ownership.\"\"\"\n    attachment = Attachment.objects.filter(\n        id=attachment_id,\n        tenant=user.tenant  # Tenant isolation\n    ).first()\n    \n    if not attachment:\n        raise Attachment.DoesNotExist()\n    \n    # Ownership validation\n    if attachment.owner != user.id:\n        # Check if user has permission to access others' files\n        if not user.has_role(['manager', 'supervisor', 'admin']):\n            raise PermissionDenied('File not owned by user')\n    \n    return attachment\n```\n\n### Step 2: Path Traversal Prevention\n\n```python\nimport os\nfrom pathlib import Path\n\ndef validate_file_path(filepath, media_root):\n    \"\"\"Prevent directory traversal attacks.\"\"\"\n    # Resolve to absolute path\n    full_path = Path(media_root) / filepath\n    resolved = full_path.resolve()\n    \n    # Ensure file stays within MEDIA_ROOT\n    if not str(resolved).startswith(str(Path(media_root).resolve())):\n        raise PermissionDenied('Path traversal attempt detected')\n    \n    # Verify file exists\n    if not resolved.exists():\n        raise FileNotFoundError('File does not exist')\n    \n    return resolved\n```\n\n### Step 3: Audit Logging\n\n```python\nimport logging\nfrom apps.core.models import AuditLog\n\nlogger = logging.getLogger(__name__)\n\ndef log_file_access(user, filepath, attachment_id, success=True):\n    \"\"\"Log all file access attempts.\"\"\"\n    AuditLog.objects.create(\n        user=user,\n        action='FILE_DOWNLOAD',\n        resource_type='Attachment',\n        resource_id=attachment_id,\n        details={\n            'filepath': filepath,\n            'success': success,\n            'ip_address': get_client_ip(request)\n        },\n        tenant=user.tenant\n    )\n    \n    if success:\n        logger.info(f'File downloaded: {filepath} by {user.username}')\n    else:\n        logger.warning(f'Unauthorized file access attempt: {filepath} by {user.username}')\n```\n\n## Testing File Security\n\n```python\nfrom django.test import TestCase\nfrom apps.peoples.models import People\nfrom apps.core.models import Attachment\n\nclass FileDownloadSecurityTests(TestCase):\n    def test_cannot_download_other_tenant_file(self):\n        \"\"\"Users cannot access files from other tenants.\"\"\"\n        tenant_a = Tenant.objects.create(name='Tenant A')\n        tenant_b = Tenant.objects.create(name='Tenant B')\n        \n        user_a = People.objects.create(username='alice', tenant=tenant_a)\n        user_b = People.objects.create(username='bob', tenant=tenant_b)\n        \n        attachment = Attachment.objects.create(\n            owner=user_b.id,\n            tenant=tenant_b,\n            filepath='uploads/sensitive.pdf'\n        )\n        \n        self.client.force_login(user_a)\n        response = self.client.get(f'/download/{attachment.id}/')\n        \n        self.assertEqual(response.status_code, 404)  # Tenant isolation\n    \n    def test_path_traversal_blocked(self):\n        \"\"\"Path traversal attacks are blocked.\"\"\"\n        user = People.objects.create(username='attacker')\n        \n        # Attempt to access /etc/passwd\n        malicious_path = '../../../etc/passwd'\n        \n        with self.assertRaises(PermissionDenied):\n            SecureFileDownloadService.validate_file_path(\n                filepath=malicious_path,\n                media_root=settings.MEDIA_ROOT\n            )\n```\n\n## Migration Guide\n\nReplace unsafe file downloads:\n\n```bash\n# Find vulnerable patterns\ngrep -r \"FileResponse(open\" apps/\ngrep -r \"HttpResponse(open\" apps/\n\n# Run security validation\npython scripts/verify_secure_file_download.py\n```\n\n## Quick Checklist\n\n- [ ] Import `SecureFileDownloadService`\n- [ ] Call `validate_attachment_access()` first\n- [ ] Use `validate_and_serve_file()` to serve\n- [ ] Handle `PermissionDenied` exceptions\n- [ ] Write security tests for cross-tenant/user access\n- [ ] Add audit logging\n\n## Documentation\n\n- [Secure File Download Service](file:///apps/core/services/secure_file_download_service.py)\n- [Security Tests](file:///tests/security/test_secure_file_download.py)\n- [Complete Remediation Report](file:///SECURE_FILE_DOWNLOAD_REMEDIATION_COMPLETE.md)",
      "category_id": 200,
      "difficulty_level": "INTERMEDIATE",
      "target_roles": ["developer", "security", "tech_lead"],
      "status": "PUBLISHED",
      "version": 1,
      "view_count": 0,
      "helpful_count": 0,
      "not_helpful_count": 0,
      "published_date": "2025-11-06T00:00:00Z",
      "last_reviewed_date": "2025-11-06T00:00:00Z"
    }
  },
  {
    "model": "help_center.helparticle",
    "pk": 2004,
    "fields": {
      "tenant_id": 1,
      "title": "How to Add Authentication to Views",
      "slug": "add-authentication-views",
      "summary": "Protect views and API endpoints with Django's authentication decorators and DRF permissions.",
      "content": "## Authentication vs Authorization\n\n- **Authentication**: Verifying who the user is (login)\n- **Authorization**: Verifying what the user can do (permissions)\n\nBoth are required for secure views.\n\n## Function-Based Views\n\n### Basic Login Required\n\n```python\nfrom django.contrib.auth.decorators import login_required\nfrom django.http import HttpResponse\n\n@login_required\ndef dashboard(request):\n    return HttpResponse(f'Welcome {request.user.username}')\n```\n\n### Permission Required\n\n```python\nfrom django.contrib.auth.decorators import permission_required\n\n@login_required\n@permission_required('work_order_management.approve_workorder', raise_exception=True)\ndef approve_work_order(request, order_id):\n    order = WorkOrder.objects.get(id=order_id)\n    order.status = 'APPROVED'\n    order.save()\n    return HttpResponse('Work order approved')\n```\n\n### Role-Based Access\n\n```python\nfrom functools import wraps\nfrom django.core.exceptions import PermissionDenied\n\ndef role_required(roles):\n    \"\"\"Decorator to check user roles.\"\"\"\n    def decorator(view_func):\n        @wraps(view_func)\n        def wrapper(request, *args, **kwargs):\n            if not request.user.is_authenticated:\n                raise PermissionDenied('Authentication required')\n            \n            user_roles = request.user.get_roles()\n            if not any(role in user_roles for role in roles):\n                raise PermissionDenied(f'Requires one of: {roles}')\n            \n            return view_func(request, *args, **kwargs)\n        return wrapper\n    return decorator\n\n@role_required(['manager', 'supervisor'])\ndef manager_dashboard(request):\n    return render(request, 'manager_dashboard.html')\n```\n\n## Class-Based Views\n\n### LoginRequiredMixin\n\n```python\nfrom django.contrib.auth.mixins import LoginRequiredMixin\nfrom django.views.generic import ListView\n\nclass WorkOrderListView(LoginRequiredMixin, ListView):\n    model = WorkOrder\n    login_url = '/auth/login/'\n    \n    def get_queryset(self):\n        # Tenant isolation\n        return WorkOrder.objects.filter(tenant=self.request.tenant)\n```\n\n### PermissionRequiredMixin\n\n```python\nfrom django.contrib.auth.mixins import PermissionRequiredMixin\nfrom django.views.generic import UpdateView\n\nclass WorkOrderApprovalView(LoginRequiredMixin, PermissionRequiredMixin, UpdateView):\n    model = WorkOrder\n    permission_required = 'work_order_management.approve_workorder'\n    raise_exception = True\n    \n    def form_valid(self, form):\n        form.instance.approved_by = self.request.user\n        form.instance.approved_at = timezone.now()\n        return super().form_valid(form)\n```\n\n## Django REST Framework APIs\n\n### IsAuthenticated Permission\n\n```python\nfrom rest_framework import viewsets\nfrom rest_framework.permissions import IsAuthenticated\n\nclass WorkOrderViewSet(viewsets.ModelViewSet):\n    queryset = WorkOrder.objects.all()\n    serializer_class = WorkOrderSerializer\n    permission_classes = [IsAuthenticated]\n    \n    def get_queryset(self):\n        # Tenant isolation\n        return WorkOrder.objects.filter(tenant=self.request.user.tenant)\n```\n\n### Custom Permissions\n\n```python\nfrom rest_framework import permissions\n\nclass IsOwnerOrManager(permissions.BasePermission):\n    \"\"\"Only owners or managers can access.\"\"\"\n    \n    def has_object_permission(self, request, view, obj):\n        # Owners can always access\n        if obj.created_by == request.user:\n            return True\n        \n        # Managers can access all\n        if request.user.has_role(['manager', 'admin']):\n            return True\n        \n        return False\n\nclass WorkOrderViewSet(viewsets.ModelViewSet):\n    permission_classes = [IsAuthenticated, IsOwnerOrManager]\n    queryset = WorkOrder.objects.all()\n```\n\n### Token Authentication\n\n```python\nfrom rest_framework.authentication import TokenAuthentication\nfrom rest_framework.permissions import IsAuthenticated\n\nclass MobileAPIViewSet(viewsets.ModelViewSet):\n    authentication_classes = [TokenAuthentication]\n    permission_classes = [IsAuthenticated]\n```\n\n## AJAX/Fetch Endpoints\n\n### CSRF Protection\n\n```python\nfrom django.views.decorators.http import require_POST\nfrom django.contrib.auth.decorators import login_required\nfrom django.http import JsonResponse\n\n@login_required\n@require_POST\ndef ajax_update_status(request):\n    # CSRF token automatically validated\n    order_id = request.POST.get('order_id')\n    new_status = request.POST.get('status')\n    \n    order = WorkOrder.objects.get(id=order_id, tenant=request.tenant)\n    order.status = new_status\n    order.save()\n    \n    return JsonResponse({'success': True})\n```\n\n### API Key Authentication (for external integrations)\n\n```python\nfrom functools import wraps\nfrom django.http import JsonResponse\n\ndef api_key_required(view_func):\n    @wraps(view_func)\n    def wrapper(request, *args, **kwargs):\n        api_key = request.headers.get('X-API-Key')\n        \n        if not api_key:\n            return JsonResponse({'error': 'API key required'}, status=401)\n        \n        try:\n            client = APIClient.objects.get(api_key=api_key, is_active=True)\n            request.api_client = client\n        except APIClient.DoesNotExist:\n            return JsonResponse({'error': 'Invalid API key'}, status=401)\n        \n        return view_func(request, *args, **kwargs)\n    return wrapper\n\n@api_key_required\ndef webhook_receiver(request):\n    # Process webhook from external system\n    return JsonResponse({'status': 'received'})\n```\n\n## Testing Authentication\n\n```python\nfrom django.test import TestCase\nfrom django.urls import reverse\n\nclass AuthenticationTests(TestCase):\n    def test_login_required(self):\n        \"\"\"Unauthenticated users are redirected to login.\"\"\"\n        response = self.client.get('/dashboard/')\n        self.assertEqual(response.status_code, 302)\n        self.assertIn('/auth/login/', response.url)\n    \n    def test_authenticated_access(self):\n        \"\"\"Authenticated users can access.\"\"\"\n        user = People.objects.create_user('alice')\n        self.client.force_login(user)\n        \n        response = self.client.get('/dashboard/')\n        self.assertEqual(response.status_code, 200)\n    \n    def test_permission_denied(self):\n        \"\"\"Users without permission are blocked.\"\"\"\n        user = People.objects.create_user('alice')\n        self.client.force_login(user)\n        \n        response = self.client.post('/work-orders/1/approve/')\n        self.assertEqual(response.status_code, 403)\n```\n\n## Common Mistakes\n\n### ❌ Missing Authentication\n\n```python\ndef sensitive_data(request):\n    # No @login_required - anyone can access!\n    return JsonResponse({'secret': 'data'})\n```\n\n### ❌ Client-Side Only Protection\n\n```javascript\n// Frontend check (can be bypassed)\nif (user.isAdmin) {\n    showAdminPanel();\n}\n```\n\nAlways validate on the backend!\n\n### ❌ Trusting User Input\n\n```python\n@login_required\ndef update_user(request, user_id):\n    # Trusts user_id from URL - IDOR vulnerability!\n    user = People.objects.get(id=user_id)\n    user.email = request.POST['email']\n    user.save()\n```\n\n## Quick Checklist\n\n- [ ] All views have `@login_required` or `LoginRequiredMixin`\n- [ ] Sensitive operations check permissions\n- [ ] API endpoints use `IsAuthenticated` permission\n- [ ] AJAX endpoints validate CSRF tokens\n- [ ] Tests verify authentication is enforced\n- [ ] Tenant isolation in all querysets\n\n## Documentation\n\n- [Django Authentication](https://docs.djangoproject.com/en/5.2/topics/auth/)\n- [DRF Permissions](https://www.django-rest-framework.org/api-guide/permissions/)\n- [Security Audit Report](file:///SECURITY_AUDIT_REPORT.md)",
      "category_id": 200,
      "difficulty_level": "BEGINNER",
      "target_roles": ["developer", "security"],
      "status": "PUBLISHED",
      "version": 1,
      "view_count": 0,
      "helpful_count": 0,
      "not_helpful_count": 0,
      "published_date": "2025-11-06T00:00:00Z",
      "last_reviewed_date": "2025-11-06T00:00:00Z"
    }
  },
  {
    "model": "help_center.helparticle",
    "pk": 2005,
    "fields": {
      "tenant_id": 1,
      "title": "How to Prevent Path Traversal Attacks",
      "slug": "prevent-path-traversal",
      "summary": "Secure file operations against directory traversal attacks that allow attackers to access files outside intended directories.",
      "content": "## Understanding Path Traversal\n\nPath traversal (directory traversal) attacks use sequences like `../` to escape restricted directories and access sensitive files:\n\n```\n# Attacker manipulates filepath parameter:\n/download?file=../../../../etc/passwd\n/export?template=../../../settings/production.py\n```\n\n## Vulnerable Code Patterns\n\n### ❌ DANGEROUS: Unsanitized Path\n\n```python\nimport os\nfrom django.conf import settings\n\ndef download_report(request):\n    # VULNERABLE: User input directly used in path\n    filename = request.GET['file']\n    filepath = os.path.join(settings.MEDIA_ROOT, filename)\n    \n    # Attacker can use: file=../../../etc/passwd\n    with open(filepath, 'rb') as f:\n        return HttpResponse(f.read())\n```\n\n### ❌ DANGEROUS: String Concatenation\n\n```python\ndef serve_static(request, path):\n    # VULNERABLE: Path not validated\n    full_path = f'/var/www/static/{path}'\n    return FileResponse(open(full_path, 'rb'))\n```\n\n## Secure Implementations\n\n### ✅ SECURE: Path Validation\n\n```python\nimport os\nfrom pathlib import Path\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.conf import settings\n\ndef safe_download(request, filename):\n    # 1. Define allowed directory\n    media_root = Path(settings.MEDIA_ROOT).resolve()\n    \n    # 2. Build requested path\n    requested_path = (media_root / filename).resolve()\n    \n    # 3. Verify path stays within allowed directory\n    try:\n        requested_path.relative_to(media_root)\n    except ValueError:\n        # Path escapes media_root\n        raise SuspiciousFileOperation(\n            f'Attempted path traversal: {filename}'\n        )\n    \n    # 4. Verify file exists\n    if not requested_path.exists() or not requested_path.is_file():\n        raise Http404('File not found')\n    \n    # 5. Serve file securely\n    return FileResponse(open(requested_path, 'rb'))\n```\n\n### ✅ SECURE: Using safe_join\n\n```python\nfrom django.utils._os import safe_join\nfrom django.conf import settings\nfrom django.core.exceptions import SuspiciousFileOperation\n\ndef download_attachment(request, filepath):\n    try:\n        # safe_join raises SuspiciousFileOperation on traversal\n        full_path = safe_join(settings.MEDIA_ROOT, filepath)\n        \n        if not os.path.exists(full_path):\n            raise Http404('File not found')\n        \n        return FileResponse(open(full_path, 'rb'))\n        \n    except SuspiciousFileOperation:\n        logger.warning(f'Path traversal attempt: {filepath}')\n        raise PermissionDenied('Invalid file path')\n```\n\n## Additional Protection Layers\n\n### Whitelist Allowed Extensions\n\n```python\nALLOWED_EXTENSIONS = {'.pdf', '.png', '.jpg', '.jpeg', '.docx', '.xlsx'}\n\ndef validate_file_extension(filename):\n    ext = os.path.splitext(filename)[1].lower()\n    if ext not in ALLOWED_EXTENSIONS:\n        raise ValidationError(f'File type not allowed: {ext}')\n```\n\n### Sanitize Filename\n\n```python\nimport re\nfrom django.utils.text import get_valid_filename\n\ndef sanitize_filename(filename):\n    # Remove path components\n    filename = os.path.basename(filename)\n    \n    # Use Django's sanitizer\n    filename = get_valid_filename(filename)\n    \n    # Additional sanitization\n    filename = re.sub(r'[^a-zA-Z0-9._-]', '', filename)\n    \n    return filename\n\n# Usage\nuser_filename = request.FILES['upload'].name\nsafe_filename = sanitize_filename(user_filename)\nfilepath = safe_join(settings.MEDIA_ROOT, safe_filename)\n```\n\n### Limit Directory Depth\n\n```python\ndef validate_path_depth(filepath, max_depth=3):\n    \"\"\"Prevent deeply nested paths.\"\"\"\n    depth = len(Path(filepath).parts)\n    if depth > max_depth:\n        raise ValidationError(f'Path too deep (max {max_depth} levels)')\n```\n\n## Comprehensive Security Function\n\n```python\nfrom pathlib import Path\nfrom django.conf import settings\nfrom django.core.exceptions import SuspiciousFileOperation, ValidationError\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass SecureFileHandler:\n    ALLOWED_EXTENSIONS = {'.pdf', '.png', '.jpg', '.jpeg', '.docx', '.xlsx'}\n    MAX_PATH_DEPTH = 3\n    \n    @staticmethod\n    def validate_and_resolve(filepath, base_dir=None):\n        \"\"\"\n        Validate file path against multiple security checks.\n        \n        Returns: Resolved absolute path\n        Raises: ValidationError or SuspiciousFileOperation\n        \"\"\"\n        if base_dir is None:\n            base_dir = settings.MEDIA_ROOT\n        \n        base_path = Path(base_dir).resolve()\n        \n        # 1. Basic sanitization\n        filepath = os.path.basename(filepath)  # Remove any path components\n        \n        # 2. Extension check\n        ext = os.path.splitext(filepath)[1].lower()\n        if ext not in SecureFileHandler.ALLOWED_EXTENSIONS:\n            raise ValidationError(f'File type not allowed: {ext}')\n        \n        # 3. Build full path\n        full_path = (base_path / filepath).resolve()\n        \n        # 4. Verify within base directory\n        try:\n            full_path.relative_to(base_path)\n        except ValueError:\n            logger.warning(f'Path traversal attempt: {filepath}')\n            raise SuspiciousFileOperation('Path traversal detected')\n        \n        # 5. Verify file exists and is a file (not directory)\n        if not full_path.exists():\n            raise FileNotFoundError(f'File not found: {filepath}')\n        \n        if not full_path.is_file():\n            raise ValidationError('Path must point to a file')\n        \n        return full_path\n\n# Usage\ndef secure_download(request, filename):\n    try:\n        filepath = SecureFileHandler.validate_and_resolve(filename)\n        return FileResponse(open(filepath, 'rb'))\n    except (ValidationError, SuspiciousFileOperation) as e:\n        return JsonResponse({'error': str(e)}, status=400)\n    except FileNotFoundError:\n        raise Http404('File not found')\n```\n\n## Testing Path Traversal Protection\n\n```python\nfrom django.test import TestCase\nfrom django.core.exceptions import SuspiciousFileOperation\nimport tempfile\nimport os\n\nclass PathTraversalTests(TestCase):\n    def setUp(self):\n        # Create temporary test directory\n        self.test_dir = tempfile.mkdtemp()\n        self.test_file = os.path.join(self.test_dir, 'safe.txt')\n        with open(self.test_file, 'w') as f:\n            f.write('Safe content')\n    \n    def test_blocks_parent_directory_access(self):\n        \"\"\"Block attempts to access parent directories.\"\"\"\n        malicious_paths = [\n            '../../../etc/passwd',\n            '..\\\\..\\\\..\\\\windows\\\\system32\\\\config\\\\sam',\n            'subdir/../../etc/passwd',\n            '....//....//etc/passwd',\n        ]\n        \n        for path in malicious_paths:\n            with self.assertRaises(SuspiciousFileOperation):\n                SecureFileHandler.validate_and_resolve(\n                    path,\n                    base_dir=self.test_dir\n                )\n    \n    def test_allows_safe_paths(self):\n        \"\"\"Allow legitimate file access.\"\"\"\n        safe_path = SecureFileHandler.validate_and_resolve(\n            'safe.txt',\n            base_dir=self.test_dir\n        )\n        self.assertTrue(safe_path.exists())\n```\n\n## Automated Security Scanning\n\n```bash\n# Find potentially vulnerable file operations\ngrep -r \"open(.*request\" apps/\ngrep -r \"os.path.join.*request\" apps/\ngrep -r \"f'.*{.*}'.*open\" apps/\n\n# Run security tests\npython -m pytest tests/security/test_path_traversal.py -v\n```\n\n## Common Attack Vectors\n\n1. **URL Parameters**: `/download?file=../../../etc/passwd`\n2. **Form Fields**: `<input name=\"template\" value=\"../../settings.py\">`\n3. **API Payloads**: `{\"filepath\": \"../../../secrets.env\"}`\n4. **Cookie Values**: `path=..%2F..%2Fetc%2Fpasswd` (URL encoded)\n5. **Headers**: `X-File-Path: ../../../../etc/passwd`\n\n## Production Monitoring\n\n```python\nimport logging\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom apps.core.models import SecurityEvent\n\nlogger = logging.getLogger(__name__)\n\ndef log_traversal_attempt(request, filepath):\n    \"\"\"Log path traversal attempts for security monitoring.\"\"\"\n    SecurityEvent.objects.create(\n        event_type='PATH_TRAVERSAL',\n        severity='HIGH',\n        user=request.user if request.user.is_authenticated else None,\n        ip_address=get_client_ip(request),\n        details={\n            'requested_path': filepath,\n            'user_agent': request.META.get('HTTP_USER_AGENT'),\n            'referer': request.META.get('HTTP_REFERER')\n        },\n        tenant=getattr(request, 'tenant', None)\n    )\n    \n    logger.warning(\n        f'Path traversal attempt from {get_client_ip(request)}: {filepath}'\n    )\n```\n\n## Quick Checklist\n\n- [ ] All file paths use `Path.resolve()` for validation\n- [ ] Paths verified to stay within allowed directories\n- [ ] Use `safe_join()` or custom validation\n- [ ] Filenames sanitized (remove path components)\n- [ ] File extensions whitelisted\n- [ ] Security tests for traversal attempts\n- [ ] Logging/monitoring for suspicious requests\n\n## Documentation\n\n- [Secure File Download Service](file:///apps/core/services/secure_file_download_service.py)\n- [Path Traversal Tests](file:///tests/security/test_path_traversal.py)\n- [Django Security Guide](https://docs.djangoproject.com/en/5.2/topics/security/)",
      "category_id": 200,
      "difficulty_level": "INTERMEDIATE",
      "target_roles": ["developer", "security", "tech_lead"],
      "status": "PUBLISHED",
      "version": 1,
      "view_count": 0,
      "helpful_count": 0,
      "not_helpful_count": 0,
      "published_date": "2025-11-06T00:00:00Z",
      "last_reviewed_date": "2025-11-06T00:00:00Z"
    }
  }
]
