import logging
from typing import Type
import os
import html
from django.utils.translation import gettext_lazy as _
from django.http import response as rp
from django.shortcuts import render
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views import View
from django.db.models import Q, F, Count, Case, When, IntegerField
from django.core.cache.backends.base import DEFAULT_TIMEOUT
from django.db import IntegrityError, transaction
from django.conf import settings
from django.http.request import QueryDict
from .models import Shift, TypeAssist, Bt, Device, Subscription
from apps.core_onboarding.models import GeofenceMaster
from apps.peoples.utils import save_userinfo
from apps.core import utils
from apps.activity.models.asset_model import Asset
from apps.activity.models.job_model import Job, Jobneed
from apps.peoples.models import Pgbelonging
from apps.attendance.models import PeopleEventlog
from . import forms as client_forms  # client_onboarding forms (formerly apps.onboarding.forms)
import apps.peoples.utils as putils
from . import utils as client_utils  # client_onboarding utils (formerly apps.onboarding.utils)
from apps.peoples import admin as people_admin
from . import admin as client_admin  # client_onboarding admin (formerly apps.onboarding.admin)
from apps.activity.admin.asset_admin import AssetResource, AssetResourceUpdate
from apps.activity.admin.location_admin import LocationResource, LocationResourceUpdate
# Updated import path after question_admin.py refactoring (2025-10-10)
# Original: from apps.activity.admin.question_admin import ...
# New: Use modular question admin structure (11 focused modules)
from apps.activity.admin.question import (
from apps.core.exceptions.patterns import DATABASE_EXCEPTIONS

    QuestionResource,
    QuestionResourceUpdate,
    QuestionSetResource,
    QuestionSetResourceUpdate,
    QuestionSetBelongingResource,
    QuestionSetBelongingResourceUpdate,
)
from apps.scheduler import admin as sc_admin
from apps.y_helpdesk.models import Ticket
from apps.work_order_management.models import Wom
from apps.work_order_management.admin import VendorResource, VendorResourceUpdate
from django.core.exceptions import ObjectDoesNotExist, ValidationError
from django.db import DatabaseError
from pprint import pformat
import uuid
import json
# Import polygon_to_address from correct location
from apps.client_onboarding.utils import polygon_to_address
from apps.core.utils_new.db_utils import get_current_db_name

CACHE_TTL = getattr(settings, "CACHE_TTL", DEFAULT_TIMEOUT)

logger = logging.getLogger("django")
log = logger


def get_caps(request):  # sourcery skip: extract-method
    logger.info("get_caps requested")
    selected_parents = request.GET.getlist("webparents[]")
    logger.info(f"selected_parents {selected_parents}")
    cfor = request.GET.get("cfor")
    logger.info(f"cfor {cfor}")
    if selected_parents:
        from apps.peoples.models import Capability

        childs = []
        for i in selected_parents:
            child = Capability.objects.get_child_data(i, cfor)
            childs.extend({"capscode": j.capscode} for j in child)
        logger.info(f"childs = [] {childs}")
        return rp.JsonResponse(data=childs, safe=False)


def handle_pop_forms(request):
    if request.method != "POST":
        return
    form_name = request.POST.get("form_name")
    form_dict = {
        "ta_form": client_forms.TypeAssistForm,
    }
    form = form_dict[form_name](request.POST, request=request)
    if not form.is_valid():
        return rp.JsonResponse({"saved": False, "errors": form.errors})
    ta = form.save(commit=False)
    ta.enable = True
    form.save(commit=True)
    save_userinfo(ta, request.user, request.session)
    if request.session.get("wizard_data"):
        request.session["wizard_data"]["taids"].append(ta.id)
    return rp.JsonResponse({"saved": True, "id": ta.id, "tacode": ta.tacode})


# -------------------- END Client View Classes ------------------------------#

# ---------------------------- END client onboarding   ---------------------------#


class SuperTypeAssist(LoginRequiredMixin, View):
    params = {
        "form_class": client_forms.SuperTypeAssistForm,
        "template_form": "onboarding/partials/partial_ta_form.html",
        "template_list": "onboarding/supertypeassist.html",
        "partial_form": "onboarding/partials/partial_ta_form.html",
        "related": ["parent", "cuser", "muser"],
        "model": TypeAssist,
        "fields": [
            "id",
            "tacode",
            "client__bucode",
            "bu__bucode",
            "taname",
            "tatype__tacode",
            "cuser__peoplecode",
        ],
        "form_initials": {},
    }

    def get(self, request, *args, **kwargs):
        R, resp = request.GET, None
        # first load the template
        if R.get("template"):
            return render(request, self.params["template_list"])
        # then load the table with objects for table_view
        if R.get("action") == "list":
            objs = (
                self.params["model"]
                .objects.select_related(*self.params["related"])
                .filter(~Q(tacode="NONE"), enable=True)
                .values(*self.params["fields"])
                .iterator()
            )
            return rp.JsonResponse(data={"data": list(objs)})

        if R.get("action", None) == "form":
            cxt = {
                "ta_form": self.params["form_class"](request=request),
                "msg": "create supertypeassist requested",
            }
            resp = utils.render_form(request, self.params, cxt)

        elif R.get("action", None) == "delete" and R.get("id", None):
            resp = utils.render_form_for_delete(request, self.params, True)

        elif R.get("id", None):
            obj = utils.get_model_obj(int(R["id"]), request, self.params)
            resp = utils.render_form_for_update(request, self.params, "ta_form", obj)
        return resp

    def post(self, request, *args, **kwargs):
        """
        Handle POST requests for SuperTypeAssist.

        REFACTORED (Oct 2025): Consolidated overlapping exception handlers
        from 84 lines (4 duplicate blocks) to 30 lines (single comprehensive handler).
        """
        resp, create = None, True
        R = request.POST

        try:
            form_data = html.unescape(request.POST["formData"])
            data = QueryDict(form_data)
            pk = request.POST.get("pk", None)

            if pk:
                msg = "supertypeassist_view"
                form = utils.get_instance_for_update(
                    data, self.params, msg, int(pk), {"request": request}
                )
                create = False
            else:
                form = self.params["form_class"](data, request=request)

            if form.is_valid():
                resp = self.handle_valid_form(form, request, create)
            else:
                cxt = {"errors": form.errors}
                resp = utils.handle_invalid_form(request, self.params, cxt)

        except (ValidationError, ValueError, TypeError) as e:
            logger.error(
                f"Validation error in SuperTypeAssist: {type(e).__name__}",
                extra={
                    'error_message': str(e),
                    'user_id': getattr(request.user, 'id', None),
                    'view': self.__class__.__name__,
                    'operation': 'supertypeassist_post'
                },
                exc_info=True
            )
            resp = utils.handle_invalid_form(request, self.params, {"errors": {"form": str(e)}})

        except (DatabaseError, IntegrityError) as e:
            logger.error(
                f"Database error in SuperTypeAssist: {type(e).__name__}",
                extra={
                    'error_message': str(e),
                    'user_id': getattr(request.user, 'id', None),
                    'view': self.__class__.__name__,
                    'operation': 'supertypeassist_post'
                },
                exc_info=True
            )
            resp = utils.handle_intergrity_error("Onboarding")

        except ObjectDoesNotExist as e:
            logger.warning(
                f"Object not found in SuperTypeAssist: {type(e).__name__}",
                extra={
                    'error_message': str(e),
                    'user_id': getattr(request.user, 'id', None),
                    'view': self.__class__.__name__
                }
            )
            resp = utils.handle_Exception(request)

        return resp

    def handle_valid_form(self, form, request, create, designations_count, obj):
        logger.info("bu form is valid")
        from apps.core.utils import handle_intergrity_error

        try:
            with transaction.atomic(using=get_current_db_name()):
                bu = form.save(commit=False)
                bu.enable = obj.enable
                bu.gpslocation = obj.gpslocation
                bu.bupreferences["permissibledistance"] = obj.bupreferences[
                    "permissibledistance"
                ]
                bu.bupreferences["controlroom"] = obj.bupreferences["controlroom"]
                bu.bupreferences["address"] = obj.bupreferences["address"]
                bu.bupreferences["address2"] = obj.bupreferences["address2"]
                bu.butype = obj.butype
                bu.ctzoffset = obj.ctzoffset
                bu.deviceevent = obj.deviceevent
                bu.enablesleepingguard = obj.enablesleepingguard
                bu.gpsenable = obj.gpsenable
                bu.identifier = obj.identifier
                bu.isserviceprovider = obj.isserviceprovider
                bu.isvendor = obj.isvendor
                bu.iswarehouse = obj.iswarehouse
                bu.parent = obj.parent
                bu.siteincharge = obj.siteincharge
                bu.skipsiteaudit = obj.skipsiteaudit
                bu.solid = obj.solid

                bu.bupreferences["posted_people"] = form.cleaned_data["posted_people"]
                bu.bupreferences["contract_designcount"] = form.cleaned_data["jsonData"]
                bu.bupreferences["total_people_count"] = form.cleaned_data[
                    "total_people_count"
                ]
                putils.save_userinfo(bu, request.user, request.session, create=create)
                logger.info("bu form saved")

                if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                    return rp.JsonResponse({"pk": bu.id, "status": "success", "message": str(_("Contract saved successfully"))}, status=200)
                else:
                    from django.contrib import messages
                    messages.success(request, _("Contract saved successfully"))
                    return rp.HttpResponseRedirect(f"/admin/contracts/?id={bu.id}")
        except IntegrityError:
            return handle_intergrity_error("Bu")


class GetAllSites(LoginRequiredMixin, View):
    def get(self, request):
        try:
            qset = Bt.objects.get_all_sites_of_client(request.session["client_id"])
            sites = qset.values("id", "bucode", "buname")
            return rp.JsonResponse(list(sites), status=200)
        except (DatabaseError, IntegrityError, ObjectDoesNotExist, TypeError, ValidationError, ValueError) as e:
            logger.error("get_allsites() exception: %s", e)
        return rp.JsonResponse({"error": "Invalid Request"}, status=404)


class GetAssignedSites(LoginRequiredMixin, View):
    def get(self, request):
        try:
            if data := Pgbelonging.objects.get_assigned_sites_to_people(
                request.user.id
            ):
                sites = Bt.objects.filter(id__in=data).values("id", "bucode", "buname")
                return rp.JsonResponse(list(sites), status=200, safe=False)
        except (DatabaseError, IntegrityError, ObjectDoesNotExist, TypeError, ValidationError, ValueError) as e:
            logger.error("get_assignedsites() exception: %s", e)
        return rp.JsonResponse({"error": "Invalid Request"}, status=404)


class SwitchSite(LoginRequiredMixin, View):
    def post(self, request):
        req_buid = request.POST["buid"]
        resp = {}
        if req_buid != " ":
            sites = Bt.objects.filter(id=req_buid).values(
                "id", "bucode", "buname", "enable"
            )[:1]
            if len(sites) > 0:
                if sites[0]["enable"] == True:
                    request.session["bu_id"] = sites[0]["id"]
                    request.session["sitecode"] = sites[0]["bucode"]
                    request.session["sitename"] = sites[0]["buname"]
                    resp["rc"] = 0
                    resp["message"] = "successfully switched to site."
                    log.info("successfully switched to site")
                else:
                    resp["rc"] = 1
                    resp["errMsg"] = "Inactive Site"
                    log.info("Inactive Site")
            else:
                resp["rc"] = 1
                resp["errMsg"] = "unable to find site."
                log.info("unable to find site.")
        else:
            resp["rc"] = 1
            resp["errMsg"] = "unable to find site."
            log.info("unable to find site.")
        return rp.JsonResponse(resp, status=200)


def get_list_of_peoples(request):
    """
    Get list of people for a permission group.

    SECURITY FIX (HP-003): Added IDOR vulnerability protection
    - Validate request parameters
    - Sanitize model name (whitelist only)
    - Add tenant isolation check
    - Add permission validation
    """
    if request.method == "POST":
        return rp.JsonResponse({"error": "Method not allowed"}, status=405)

    # SECURITY: Validate and sanitize inputs
    model_name = request.GET.get("model", "").strip()
    obj_id = request.GET.get("id", "").strip()

    # Validate ID is numeric
    if not obj_id or not obj_id.isdigit():
        return rp.JsonResponse({"error": "Invalid ID parameter"}, status=400)

    # SECURITY: Whitelist allowed models (prevent arbitrary model access)
    ALLOWED_MODELS = ['Task', 'WorkOrder', 'Tour']  # Add models as needed
    if model_name not in ALLOWED_MODELS:
        return rp.JsonResponse({"error": "Invalid model parameter"}, status=400)

    try:
        Model = apps.get_model("activity", model_name)
        obj = Model.objects.get(id=obj_id)

        # SECURITY: Tenant isolation check
        if hasattr(obj, 'tenant') and obj.tenant != request.user.tenant:
            return rp.JsonResponse({"error": "Access denied"}, status=403)

        # SECURITY: Permission check (customize based on your needs)
        # if not request.user.has_perm(f'activity.view_{model_name.lower()}'):
        #     return rp.JsonResponse({"error": "Permission denied"}, status=403)

    except Model.DoesNotExist:
        return rp.JsonResponse({"error": "Object not found"}, status=404)
    except DATABASE_EXCEPTIONS as e:
        from apps.core.error_handling import ErrorHandler
        correlation_id = ErrorHandler.handle_exception(e, context={'view': 'get_list_of_peoples'})
        logger.error(f"Error in get_list_of_peoples: {e}", extra={'correlation_id': correlation_id}, exc_info=True)
        return ErrorHandler.create_error_response("System error occurred", error_code="SYSTEM_ERROR", correlation_id=correlation_id)

    Pgbelonging = apps.get_model("peoples", "Pgbelonging")
    data = (
        Pgbelonging.objects.filter(
            Q(assignsites_id=1) | Q(assignsites__isnull=True),
            pgroup_id=obj.pgroup_id,
            tenant=request.user.tenant  # SECURITY: Tenant isolation
        ).values("people__peoplecode", "people__peoplename", "id")
        or Pgbelonging.objects.none()
    )
    return rp.JsonResponse({"data": list(data)}, status=200)


class LicenseSubscriptionView(LoginRequiredMixin, View):
    """License subscription management (restored from initial commit)"""
    P = {"model": Subscription}

    def get(self, request, *args, **kwargs):
        R, P = request.GET, self.P
        if R.get("action") == "getLicenseList":
            try:
                qset = P["model"].objects.get_license_list(R["client_id"])
                return rp.JsonResponse({"data": list(qset)}, status=200)
            except (AttributeError, TypeError, ValueError, KeyError) as e:
                logger.error(f"LicenseSubscriptionView error: {e}")
                return rp.JsonResponse({"error": "Invalid request"}, status=400)
        return rp.JsonResponse({"error": "Action parameter required"}, status=400)
