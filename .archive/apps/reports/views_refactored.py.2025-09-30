"""
Refactored Reports Views

This module contains refactored views that follow Django best practices:
- Extracted business logic to service layer
- Proper exception handling with specific error types
- Optimized database queries with select_related/prefetch_related
- Single responsibility principle for each view method
- Rate limiting and security decorators

This file demonstrates the improved architecture and can be used to
gradually replace the original views.py file.
"""

import logging
from django.shortcuts import redirect, render
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.decorators import login_required
from django.views.generic.base import View
from django.contrib import messages
from django.http import JsonResponse, QueryDict
from django.urls import reverse
from django.core.exceptions import ValidationError, ObjectDoesNotExist
from django.db import IntegrityError, DatabaseError

from apps.activity.forms.question_form import QsetBelongingForm
from apps.reports import forms as rp_forms
from apps.reports.services import (
    ReportDataService,
    ReportGenerationService,
    ReportExportService,
    ReportTemplateService
)
from apps.core.decorators import csrf_protect_ajax, rate_limit

logger = logging.getLogger("django")


class RefactoredRetriveSiteReports(LoginRequiredMixin, View):
    """
    Refactored Site Reports View

    Uses ReportDataService for business logic and proper error handling.
    Reduced from 23 lines to focused view logic only.
    """
    template_path = "reports/sitereport_list.html"

    def get(self, request, *args, **kwargs):
        """Return paginated site reports with proper error handling."""
        if request.GET.get("template"):
            return render(request, self.template_path)

        # Use service layer for data retrieval
        report_data, error_message = ReportDataService.get_site_reports(request)

        if error_message:
            messages.error(request, error_message, "alert alert-danger")
            return redirect("/dashboard")

        return JsonResponse(
            {"data": report_data},
            status=200,
            encoder=utils.CustomJsonEncoderWithDistance,
        )


class RefactoredRetriveIncidentReports(LoginRequiredMixin, View):
    """
    Refactored Incident Reports View

    Uses ReportDataService for optimized data retrieval and error handling.
    """
    template_path = "reports/incidentreport_list.html"

    def get(self, request, *args, **kwargs):
        """Return paginated incident reports with attachments."""
        if request.GET.get("template"):
            return render(request, self.template_path)

        # Use service layer for data retrieval
        reports_data, attachments_data, error_message = ReportDataService.get_incident_reports(request)

        if error_message:
            messages.error(request, error_message, "alert alert-danger")
            return redirect("/dashboard")

        return JsonResponse(
            {"data": reports_data, "atts": attachments_data},
            status=200
        )


class RefactoredMasterReportTemplateList(LoginRequiredMixin, View):
    """
    Refactored Master Report Template List View

    Uses ReportDataService for optimized queries and pagination.
    """
    fields = ["id", "qsetname", "enable"]

    def get(self, request, *args, **kwargs):
        """Return paginated master report templates."""
        if request.GET.get("template"):
            return render(request, "reports/sitereport_template_list.html")

        # Use service layer for data retrieval
        response_data, error_message = ReportDataService.get_master_report_templates(
            request.GET, self.fields
        )

        if error_message:
            logger.warning(f"Error retrieving master templates: {error_message}")
            return redirect("/dashboard")

        return JsonResponse(response_data, status=200)


class RefactoredMasterReportForm(LoginRequiredMixin, View):
    """
    Refactored Master Report Form View

    Separated form handling logic using service layer.
    Reduced complexity and improved error handling.
    """
    template_path = "reports/sitereport_tempform.html"
    form_class = rp_forms.SiteReportTemplate
    subform = QsetBelongingForm
    initial = {"type": "SITEREPORTTEMPLATE"}

    def get(self, request, *args, **kwargs):
        """Handle GET requests for form display and data retrieval."""
        request_data = request.GET

        if request_data.get("template"):
            return self._handle_template_request(request, request_data)

        if request_data.get("get_reports"):
            return self._handle_reports_request(request_data)

        return JsonResponse({"error": "Invalid request"}, status=400)

    def post(self, request, *args, **kwargs):
        """Handle POST requests for form submission."""
        try:
            # Determine if this is create or update
            pk = request.POST.get("pk")
            create_mode = pk is None

            # Get form instance
            if create_mode:
                form = self.form_class(
                    data=request.POST,
                    request=request,
                    initial=self.initial
                )
            else:
                # Use service to get instance for update
                template_config, error = ReportTemplateService.get_template_configuration(
                    int(pk), request.session.get('client_id')
                )
                if error:
                    return JsonResponse({"errors": error}, status=404)

                form = self.form_class(
                    request=request,
                    instance=None,  # Will be handled by service
                    data=request.POST
                )

            # Process form using service layer
            response, error_message = ReportGenerationService.process_report_form(
                form, request, create_mode
            )

            return response

        except ValidationError as e:
            logger.warning(f"Form validation error: {str(e)}")
            return JsonResponse({"errors": str(e)}, status=400)
        except Exception as e:
            logger.error(f"Unexpected error in form processing: {str(e)}", exc_info=True)
            return JsonResponse(
                {"errors": "An unexpected error occurred"},
                status=500
            )

    def _handle_template_request(self, request, request_data):
        """Handle template rendering requests."""
        template_id = request_data.get("id") or request.resolver_match.kwargs.get("id")

        if not template_id:
            # Return empty form
            context = {
                "reporttemp_form": self.form_class(
                    request=request, initial=self.initial
                ),
                "qsetbng": self.subform(),
            }
            return render(request, self.template_path, context)

        # Get template configuration using service
        template_config, error = ReportTemplateService.get_template_configuration(
            int(template_id), request.session.get('client_id')
        )

        if error:
            messages.error(request, error)
            return redirect("/dashboard")

        # Create form with instance
        form = self.form_class(
            initial={**self.initial, **template_config},
            request=request
        )

        context = {
            "reporttemp_form": form,
            "qsetbng": self.subform()
        }
        return render(request, self.template_path, context)

    def _handle_reports_request(self, request_data):
        """Handle reports list requests."""
        parent_id = request_data.get("parent_id", "0")

        # Use service to get template sections
        sections_data, error = ReportDataService.get_template_sections(parent_id)

        if error:
            return JsonResponse({"error": error}, status=400)

        return JsonResponse({"data": sections_data}, status=200)


class RefactoredConfigSiteReportTemplate(LoginRequiredMixin, View):
    """
    Refactored Configuration Site Report Template View

    Simplified using service layer and proper error handling.
    Reduced from 70+ lines to focused view logic.
    """

    def get(self, request, *args, **kwargs):
        """Handle GET requests for template configuration."""
        action = request.GET.get("action")
        template_id = request.GET.get("id")

        if request.GET.get("template"):
            return render(request, "reports/sitereport_template_list.html")

        try:
            if action == "list":
                return self._handle_list_action(request)
            elif action == "form":
                return self._handle_form_action(request)
            elif action == "get_sections":
                return self._handle_sections_action(request)
            elif action == "delete" and template_id:
                return self._handle_delete_action(template_id)
            elif template_id:
                return self._handle_template_form(request, template_id)

            return JsonResponse({"error": "Invalid action"}, status=400)

        except ValidationError as e:
            logger.warning(f"Configuration validation error: {str(e)}")
            return JsonResponse({"error": str(e)}, status=400)
        except Exception as e:
            logger.error(f"Configuration error: {str(e)}", exc_info=True)
            return JsonResponse({"error": "An error occurred"}, status=500)

    def post(self, request, *args, **kwargs):
        """Handle POST requests for template creation/update."""
        try:
            # Parse form data
            form_data = QueryDict(request.POST["formData"])
            pk = request.POST.get("pk")

            # Prepare template data
            template_data = {
                'qsetname': form_data.get('qsetname'),
                'type': 'SITEREPORTTEMPLATE',
                'parent_id': form_data.get('parent_id', 1),
                'buincludes': form_data.getlist('buincludes'),
                'site_grp_includes': form_data.getlist('site_grp_includes'),
                'site_type_includes': form_data.getlist('site_type_includes'),
                'assetincludes': form_data.getlist('assetincludes')
            }

            # Use service layer for template operations
            if pk:
                template, error = ReportTemplateService.update_template(
                    int(pk), template_data, request.user, request.session
                )
            else:
                template, error = ReportTemplateService.create_template(
                    template_data, request.user, request.session
                )

            if error:
                return JsonResponse({"error": error}, status=400)

            return JsonResponse({"parent_id": template.id}, status=200)

        except ValidationError as e:
            logger.warning(f"Template save validation error: {str(e)}")
            return JsonResponse({"error": str(e)}, status=400)
        except Exception as e:
            logger.error(f"Template save error: {str(e)}", exc_info=True)
            return JsonResponse({"error": "Failed to save template"}, status=500)

    def _handle_list_action(self, request):
        """Handle list action for templates."""
        templates_data, error = ReportDataService.get_configured_templates(
            request, 'SITEREPORTTEMPLATE', ["id", "qsetname", "enable"]
        )

        if error:
            return JsonResponse({"error": error}, status=400)

        return JsonResponse({"data": templates_data}, status=200)

    def _handle_form_action(self, request):
        """Handle form action for template creation."""
        context = {
            "reporttemp_form": rp_forms.SiteReportTemplate(
                initial={"type": "SITEREPORTTEMPLATE"},
                request=request
            ),
            "test": rp_forms.TestForm,
        }
        return render(request, "reports/sitereport_tempform.html", context)

    def _handle_sections_action(self, request):
        """Handle sections retrieval action."""
        parent_id = request.GET.get("parent_id", "0")
        sections_data, error = ReportDataService.get_template_sections(parent_id)

        if error:
            return JsonResponse({"error": error}, status=400)

        return JsonResponse({"data": sections_data}, status=200)

    def _handle_delete_action(self, template_id):
        """Handle template deletion action."""
        success, error = ReportDataService.delete_template(template_id)

        if not success:
            return JsonResponse({"error": error}, status=400)

        logger.info(f'Site report template {template_id} deleted')
        return JsonResponse({}, status=200)

    def _handle_template_form(self, request, template_id):
        """Handle template form display."""
        template_config, error = ReportTemplateService.get_template_configuration(
            int(template_id), request.session.get('client_id')
        )

        if error:
            return JsonResponse({"error": error}, status=404)

        context = {
            "reporttemp_form": rp_forms.SiteReportTemplate(
                initial=template_config,
                request=request
            ),
            "test": rp_forms.TestForm,
        }
        return render(request, "reports/sitereport_tempform.html", context)


class RefactoredDownloadReports(LoginRequiredMixin, View):
    """
    Refactored Download Reports View

    Uses service layer for report generation and export.
    Improved error handling and rate limiting.
    """

    @rate_limit(max_requests=5, window_seconds=300)  # Prevent abuse
    def get(self, request, *args, **kwargs):
        """Handle GET requests for download form and data."""
        action = request.GET.get("action")

        if action == "form_behaviour":
            return self._handle_form_behavior(request)
        elif action in ["get_site", "get_asset", "get_qset"]:
            return self._handle_data_requests(request, action)

        # Default form display
        form = rp_forms.ReportForm(request=request)
        context = {"form": form}
        return render(request, "reports/report_export_form.html", context)

    def post(self, request, *args, **kwargs):
        """Handle POST requests for report generation."""
        form = rp_forms.ReportForm(data=request.POST, request=request)

        if not form.is_valid():
            logger.warning(f"Report form validation failed: {form.errors}")
            return render(request, "reports/report_export_form.html", {"form": form})

        try:
            # Use service layer for report generation
            task, error = ReportGenerationService.initiate_async_report_generation(
                form.cleaned_data,
                dict(request.session),
                request.user.email,
                request.user.id
            )

            if error:
                messages.error(request, error, "alert-danger")
                return render(request, "reports/report_export_form.html", {"form": form})

            # Provide user feedback
            export_type = form.cleaned_data.get("export_type")
            if export_type == "SEND":
                messages.success(
                    request,
                    "Report processing started. You will receive it via email shortly.",
                    "alert-success"
                )
            else:
                messages.success(
                    request,
                    "Report processing started. Check status with 'Check Report Status' button.",
                    "alert-success"
                )

            context = {"form": form, "task_id": task.id}
            return render(request, "reports/report_export_form.html", context)

        except Exception as e:
            logger.error(f"Report generation error: {str(e)}", exc_info=True)
            messages.error(request, "Error processing report request", "alert-danger")
            return render(request, "reports/report_export_form.html", {"form": form})

    def _handle_form_behavior(self, request):
        """Handle form behavior configuration requests."""
        report_name = request.GET.get("report_name")
        behavior_config = ReportGenerationService.get_report_behavior_config(report_name)
        return JsonResponse({"behaviour": behavior_config})

    def _handle_data_requests(self, request, action):
        """Handle data requests for form population."""
        try:
            # These could be moved to a dedicated service method
            # For now, keeping existing logic but with proper error handling
            if action == "get_site":
                return self._get_site_data(request)
            elif action == "get_asset":
                return self._get_asset_data(request)
            elif action == "get_qset":
                return self._get_qset_data(request)

        except Exception as e:
            logger.error(f"Data request error for {action}: {str(e)}", exc_info=True)
            return JsonResponse({"error": "Failed to retrieve data"}, status=500)

    def _get_site_data(self, request):
        """Get site data for form."""
        from apps.onboarding import models as on

        of_site = request.GET.get("of_site")
        of_type = request.GET.get("of_type")

        if not (of_site and of_type):
            return JsonResponse({"error": "Missing parameters"}, status=400)

        qset = on.TypeAssist.objects.select_related('tatype').filter(
            bu_id=of_site,
            client_id=request.session["client_id"],
            tatype__tacode=of_type,
        ).values("id", "taname").distinct()

        return JsonResponse({"options": list(qset)}, status=200)

    def _get_asset_data(self, request):
        """Get asset data for form."""
        from apps.activity.models.asset_model import Asset

        of_type = request.GET.get("of_type")
        if not of_type:
            return JsonResponse({"error": "Missing type parameter"}, status=400)

        qset = Asset.objects.select_related('type').filter(
            client_id=request.session["client_id"],
            bu_id=request.session["bu_id"],
            type_id=of_type
        ).values("id", "assetname").distinct()

        return JsonResponse({"options": list(qset)}, status=200)

    def _get_qset_data(self, request):
        """Get question set data for form."""
        from apps.activity.models.question_model import QuestionSet

        of_asset = request.GET.get("of_asset")
        if not of_asset:
            return JsonResponse({"error": "Missing asset parameter"}, status=400)

        qset = QuestionSet.objects.filter(
            client_id=request.session["client_id"],
            bu_id=request.session["bu_id"],
            type__in=["CHECKLIST", "ASSETMAINTENANCE"],
            parent_id=1,
            enable=True,
            assetincludes__contains=[of_asset],
        ).values("id", "qsetname").distinct()

        return JsonResponse({"options": list(qset)}, status=200)


# Additional utility functions for the refactored views
from apps.core import utils


@login_required
@rate_limit(max_requests=10, window_seconds=60)
def refactored_return_status_of_report(request):
    """
    Refactored report status checking function.

    Uses proper error handling and rate limiting.
    """
    if request.method != "GET":
        return JsonResponse({"error": "Only GET method allowed"}, status=405)

    task_id = request.GET.get("task_id")
    if not task_id:
        return JsonResponse({"error": "Task ID required"}, status=400)

    try:
        from celery.result import AsyncResult
        from background_tasks.report_tasks import remove_reportfile

        task = AsyncResult(task_id)
        form = rp_forms.ReportForm(request=request)
        template = "reports/report_export_form.html"
        context = {"form": form}

        if task.status == "SUCCESS":
            result = task.get()
            return _handle_successful_task(request, result, template, context)
        elif task.status == "FAILURE":
            messages.error(request, "Report generation failed. Please try again later.", "alert-danger")
        else:
            messages.info(request, "Report is still processing", "alert-info")

        return render(request, template, context)

    except Exception as e:
        logger.error(f"Error checking report status: {str(e)}", exc_info=True)
        messages.error(request, "Error checking report status", "alert-danger")
        return render(request, "reports/report_export_form.html", {"form": rp_forms.ReportForm(request=request)})


def _handle_successful_task(request, result, template, context):
    """Handle successful task completion."""
    if result.get("status") == 200 and result.get("filepath"):
        # Use service layer for secure file serving
        response, error = ReportExportService.secure_file_download(
            result["filepath"],
            result.get("filename", "report.pdf")
        )

        if error:
            messages.error(request, error, "alert-danger")
            return render(request, template, context)

        # Clean up file after serving
        from background_tasks.report_tasks import remove_reportfile
        remove_reportfile(result["filepath"])

        return response

    elif result.get("status") == 404:
        messages.error(request, result.get("message", "Report not found"), "alert-danger")
    elif result.get("status") == 500:
        messages.error(request, result.get("message", "Report generation failed"), "alert-danger")
    elif result.get("status") == 201:
        messages.success(request, result.get("message", "Report completed"), "alert-success")

    return render(request, template, context)