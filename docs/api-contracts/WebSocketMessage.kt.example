/**
 * WebSocket Message Types for YOUTILITY Mobile SDK
 *
 * Generated from: docs/api-contracts/websocket-messages.json
 * DO NOT EDIT MANUALLY
 *
 * Usage:
 *   1. Copy this file to your Kotlin project
 *   2. Adjust package name as needed
 *   3. Use kotlinx-serialization for JSON parsing
 *
 * Example:
 *   val json = """{"type":"heartbeat","timestamp":"2025-10-05T12:00:00Z"}"""
 *   val message = Json.decodeFromString<WebSocketMessage>(json)
 *   when (message) {
 *       is WebSocketMessage.Heartbeat -> handleHeartbeat(message)
 *       is WebSocketMessage.SyncStart -> handleSyncStart(message)
 *       // ... other types
 *   }
 */

package com.youtility.api.websocket

import kotlinx.serialization.*
import kotlinx.serialization.json.*
import java.time.Instant

/**
 * Sealed class for all WebSocket messages.
 * Uses type discriminator for polymorphic deserialization.
 */
@Serializable
sealed class WebSocketMessage {
    abstract val type: String

    /**
     * Server confirmation after WebSocket connection.
     * Sent immediately after successful authentication.
     */
    @Serializable
    @SerialName("connection_established")
    data class ConnectionEstablished(
        override val type: String = "connection_established",
        @SerialName("user_id") val userId: String,
        @SerialName("device_id") val deviceId: String,
        @SerialName("server_time") val serverTime: Instant,
        val features: Map<String, Boolean>
    ) : WebSocketMessage()

    /**
     * Periodic heartbeat to keep connection alive.
     * Server sends every 30 seconds, client should respond.
     */
    @Serializable
    @SerialName("heartbeat")
    data class Heartbeat(
        override val type: String = "heartbeat",
        val timestamp: Instant
    ) : WebSocketMessage()

    /**
     * Client initiates sync for a specific domain.
     * Supports both full and delta (incremental) sync.
     */
    @Serializable
    @SerialName("start_sync")
    data class SyncStart(
        override val type: String = "start_sync",
        val domain: SyncDomain,
        @SerialName("since_timestamp") val sinceTimestamp: Instant? = null,
        @SerialName("full_sync") val fullSync: Boolean = false,
        @SerialName("device_id") val deviceId: String
    ) : WebSocketMessage()

    /**
     * Client sends sync data payload.
     * Must include idempotency key for retry safety.
     */
    @Serializable
    @SerialName("sync_data")
    data class SyncData(
        override val type: String = "sync_data",
        val payload: JsonObject,
        @SerialName("idempotency_key") val idempotencyKey: String,
        val domain: String,
        @SerialName("client_timestamp") val clientTimestamp: Instant
    ) : WebSocketMessage()

    /**
     * Client signals sync completion for a domain.
     */
    @Serializable
    @SerialName("sync_complete")
    data class SyncComplete(
        override val type: String = "sync_complete",
        val domain: String,
        @SerialName("item_count") val itemCount: Int
    ) : WebSocketMessage()

    /**
     * Server pushes data to client (real-time updates).
     * Used for delta sync and push notifications.
     */
    @Serializable
    @SerialName("server_data")
    data class ServerData(
        override val type: String = "server_data",
        val domain: String,
        val data: List<JsonObject>,
        @SerialName("next_sync_token") val nextSyncToken: String? = null,
        @SerialName("server_timestamp") val serverTimestamp: Instant
    ) : WebSocketMessage()

    /**
     * Server requests specific data from client.
     */
    @Serializable
    @SerialName("server_data_request")
    data class ServerDataRequest(
        override val type: String = "server_data_request",
        val domain: String,
        @SerialName("entity_ids") val entityIds: List<String>,
        @SerialName("request_id") val requestId: String
    ) : WebSocketMessage()

    /**
     * Server notifies client of sync conflicts.
     * Client must resolve conflicts and resend.
     */
    @Serializable
    @SerialName("conflict_notification")
    data class ConflictNotification(
        override val type: String = "conflict_notification",
        val conflicts: List<JsonObject>,
        @SerialName("resolution_required") val resolutionRequired: Boolean,
        @SerialName("conflict_ids") val conflictIds: List<String>
    ) : WebSocketMessage()

    /**
     * Client provides manual conflict resolution.
     */
    @Serializable
    @SerialName("conflict_resolution")
    data class ConflictResolution(
        override val type: String = "conflict_resolution",
        @SerialName("conflict_id") val conflictId: String,
        val strategy: ResolutionStrategy,
        val data: JsonObject? = null
    ) : WebSocketMessage()

    /**
     * Server provides sync status update.
     */
    @Serializable
    @SerialName("sync_status")
    data class SyncStatus(
        override val type: String = "sync_status",
        val domain: String,
        val status: SyncStatusValue,
        val progress: Map<String, JsonElement> = emptyMap()
    ) : WebSocketMessage()

    /**
     * Server reports error to client.
     * Client should handle based on error_code and retryable flag.
     */
    @Serializable
    @SerialName("error")
    data class Error(
        override val type: String = "error",
        @SerialName("error_code") val errorCode: String,
        val message: String,
        val retryable: Boolean = true,
        val details: Map<String, JsonElement>? = null
    ) : WebSocketMessage()
}

/**
 * Data domains that can be synced.
 */
@Serializable
enum class SyncDomain {
    @SerialName("voice") VOICE,
    @SerialName("attendance") ATTENDANCE,
    @SerialName("task") TASK,
    @SerialName("journal") JOURNAL,
    @SerialName("ticket") TICKET
}

/**
 * Conflict resolution strategies.
 */
@Serializable
enum class ResolutionStrategy {
    @SerialName("client_wins") CLIENT_WINS,
    @SerialName("server_wins") SERVER_WINS,
    @SerialName("merge") MERGE,
    @SerialName("manual") MANUAL
}

/**
 * Sync status values.
 */
@Serializable
enum class SyncStatusValue {
    @SerialName("pending") PENDING,
    @SerialName("in_progress") IN_PROGRESS,
    @SerialName("completed") COMPLETED,
    @SerialName("failed") FAILED
}

// Example usage:
/*
class WebSocketClient(private val url: String) {
    private val json = Json { ignoreUnknownKeys = true }

    suspend fun connect() {
        // WebSocket connection logic...
    }

    suspend fun handleMessage(rawMessage: String) {
        try {
            val message = json.decodeFromString<WebSocketMessage>(rawMessage)
            when (message) {
                is WebSocketMessage.ConnectionEstablished -> {
                    Log.d("WS", "Connected as user ${message.userId}")
                    Log.d("WS", "Features: ${message.features}")
                }
                is WebSocketMessage.Heartbeat -> {
                    // Send heartbeat response
                    sendMessage(WebSocketMessage.Heartbeat(timestamp = Instant.now()))
                }
                is WebSocketMessage.ServerData -> {
                    // Process server data
                    message.data.forEach { item ->
                        processSyncItem(message.domain, item)
                    }
                }
                is WebSocketMessage.Error -> {
                    if (message.retryable) {
                        // Retry logic
                        scheduleRetry()
                    } else {
                        // Fatal error
                        showError(message.message)
                    }
                }
                // Handle other message types...
            }
        } catch (e: SerializationException) {
            Log.e("WS", "Failed to parse message: ${e.message}")
        }
    }

    suspend fun sendMessage(message: WebSocketMessage) {
        val json = json.encodeToString(WebSocketMessage.serializer(), message)
        // Send via WebSocket...
    }
}
*/
